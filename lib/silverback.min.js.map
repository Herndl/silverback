{"version":3,"sources":["silverback.min.js","node_modules/browser-pack/_prelude.js","src/core/ComponentMatchingFamily.ts","src/core/Engine.ts","src/core/EntityList.ts","src/core/NodeList.ts","src/core/NodePool.ts","src/core/SceneList.ts","src/core/System.ts","src/core/SystemList.ts","src/index.ts","src/utils/Dictionary.ts","src/utils/Signal.ts","src/utils/SignalBinding.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","NodePool_1","NodeList_1","Dictionary_1","ComponentMatchingFamily","nodeClass","engine","this","_nodeClass","_engine","_nodes","NodeList","_entities","Dictionary","_components","nodeClassPrototype","prototype","property","hasOwnProperty","componentObject","types","add","_nodePool","NodePool","dispose","get","Object","defineProperty","enumerable","configurable","newEntity","entity","addIfMatch","componentAddedToEntity","componentClass","componentRemovedFromEntity","has","removeIfMatch","removeEntity","forEach","componentName","node","componentRemoved","getValue","remove","updating","cache","updateComplete","_releaseNodePoolCache","releaseCache","cleanUp","head","next","removeAll","../utils/Dictionary","./NodeList","./NodePool",2,"EntityList_1","SceneList_1","SystemList_1","Signal_1","ComponentMatchingFamily_1","Engine","_entityList","EntityList","_entityNames","_sceneNames","_sceneList","SceneList","_systemList","SystemList","_families","Signal","familyClass","tmpEntities","push","tmpScenes","scene","tmpSystems","system","addEntity","name","componentAdded","_componentAdded","_componentRemoved","nameChanged","_entityNameChanged","nodeObject","family","getEntityByName","removeAllEntities","addScene","_sceneNameChanged","removeScene","removeAllScenes","getSceneByName","getScene","type","getNodeList","nodeList","releaseNodeList","addSystem","priority","addToEngine","getSystem","removeSystem","removeFromEngine","removeAllSystems","update","time","dispatch","oldName","../utils/Signal","./ComponentMatchingFamily","./EntityList","./SceneList","./SystemList",3,"tail","previous","_removeAll",4,"nodeAdded","nodeRemoved","empty","swap","node1","node2","temp","insertionSort","sortFunction","remains","other","mergeSort","lists","end","start","_merge","head1","head2",5,"components","_tail","newNode","_cacheTail",6,"is",7,"System","isPrototypeOf",8,9,"__export","m","p","./core/Engine","./core/System",10,"_keys","_values","key","value","keyIndex","getIndex","removedValue","splice","testKey","len","values","arValue","action","breakHere",11,"SignalBinding_1","_bindings","_prevParams","memorize","_shouldPropagate","active","validateListener","listener","fnName","replace","_registerListener","isOnce","listenerContext","binding","prevIndex","_indexOfListener","SignalBinding","_addBinding","execute","context","cur","getListener","addOnce","_destroy","getNumListeners","halt","paramsArr","_i","arguments","bindings","slice","forget","toString","VERSION","./SignalBinding",12,"signal","params","_listener","_isOnce","_signal","handlerReturn","concat","apply","detach","isBound","getSignal"],"mappings":"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","file":"silverback.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar NodePool_1 = require('./NodePool');\nvar NodeList_1 = require('./NodeList');\nvar Dictionary_1 = require('../utils/Dictionary');\nvar ComponentMatchingFamily = (function () {\n    function ComponentMatchingFamily(nodeClass, engine) {\n        this._nodeClass = nodeClass;\n        this._engine = engine;\n        this._nodes = new NodeList_1.NodeList();\n        this._entities = new Dictionary_1.Dictionary();\n        this._components = new Dictionary_1.Dictionary();\n        var nodeClassPrototype = this._nodeClass.prototype;\n        for (var property in nodeClassPrototype) {\n            if (nodeClassPrototype.hasOwnProperty(property) &&\n                property !== 'types' &&\n                property !== 'next' &&\n                property !== 'previous' &&\n                property !== 'constructor' &&\n                property !== 'super' &&\n                property !== 'extend' &&\n                property !== 'entity') {\n                var componentObject = nodeClassPrototype.types[property];\n                this._components.add(componentObject, property);\n            }\n        }\n        this._nodePool = new NodePool_1.NodePool(this._nodeClass, this._components);\n        this._nodePool.dispose(this._nodePool.get());\n    }\n    Object.defineProperty(ComponentMatchingFamily.prototype, \"nodeList\", {\n        get: function () {\n            return this._nodes;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ComponentMatchingFamily.prototype.newEntity = function (entity) {\n        this.addIfMatch(entity);\n    };\n    ComponentMatchingFamily.prototype.componentAddedToEntity = function (entity, componentClass) {\n        this.addIfMatch(entity);\n    };\n    ComponentMatchingFamily.prototype.componentRemovedFromEntity = function (entity, componentClass) {\n        if (this._components.has(componentClass)) {\n            this.removeIfMatch(entity);\n        }\n    };\n    ComponentMatchingFamily.prototype.removeEntity = function (entity) {\n        this.removeIfMatch(entity);\n    };\n    ComponentMatchingFamily.prototype.addIfMatch = function (entity) {\n        if (!this._entities.has(entity)) {\n            var componentClass;\n            if (!this._components.forEach(function (componentClass, componentName) {\n                if (!entity.has(componentClass)) {\n                    return 'return';\n                }\n            })) {\n                return;\n            }\n            var node = this._nodePool.get();\n            node.entity = entity;\n            this._components.forEach(function (componentClass, componentName) {\n                node[componentName] = entity.get(componentClass);\n            });\n            this._entities.add(entity, node);\n            entity.componentRemoved.add(this.componentRemovedFromEntity, this);\n            this._nodes.add(node);\n        }\n    };\n    ComponentMatchingFamily.prototype.removeIfMatch = function (entity) {\n        if (this._entities.getValue(entity)) {\n            var node = this._entities.getValue(entity);\n            this._entities.remove(entity);\n            this._nodes.remove(node);\n            if (this._engine.updating) {\n                this._nodePool.cache(node);\n                this._engine.updateComplete.add(this._releaseNodePoolCache, this);\n            }\n            else {\n                this._nodePool.dispose(node);\n            }\n        }\n    };\n    ComponentMatchingFamily.prototype._releaseNodePoolCache = function () {\n        this._engine.updateComplete.remove(this._releaseNodePoolCache);\n        this._nodePool.releaseCache();\n    };\n    ComponentMatchingFamily.prototype.cleanUp = function () {\n        for (var node = this._nodes.head; node; node = node.next) {\n            this._entities.remove(node.entity);\n        }\n        this._nodes.removeAll();\n    };\n    return ComponentMatchingFamily;\n})();\nexports.ComponentMatchingFamily = ComponentMatchingFamily;\n\n},{\"../utils/Dictionary\":10,\"./NodeList\":4,\"./NodePool\":5}],2:[function(require,module,exports){\nvar EntityList_1 = require('./EntityList');\nvar SceneList_1 = require('./SceneList');\nvar SystemList_1 = require('./SystemList');\nvar Dictionary_1 = require('../utils/Dictionary');\nvar Signal_1 = require('../utils/Signal');\nvar ComponentMatchingFamily_1 = require('./ComponentMatchingFamily');\nvar Engine = (function () {\n    function Engine() {\n        this._entityList = new EntityList_1.EntityList();\n        this._entityNames = new Dictionary_1.Dictionary();\n        this._sceneNames = new Dictionary_1.Dictionary();\n        this._sceneList = new SceneList_1.SceneList();\n        this._systemList = new SystemList_1.SystemList();\n        this._families = new Dictionary_1.Dictionary();\n        this.updateComplete = new Signal_1.Signal();\n        this.familyClass = ComponentMatchingFamily_1.ComponentMatchingFamily;\n    }\n    Object.defineProperty(Engine.prototype, \"entities\", {\n        get: function () {\n            var tmpEntities = [];\n            for (var entity = this._entityList.head; entity; entity = entity.next) {\n                tmpEntities.push(entity);\n            }\n            return tmpEntities;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Engine.prototype, \"scenes\", {\n        get: function () {\n            var tmpScenes = [];\n            for (var scene = this._sceneList.head; scene; scene = scene.next) {\n                tmpScenes.push(scene);\n            }\n            return tmpScenes;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Engine.prototype, \"systems\", {\n        get: function () {\n            var tmpSystems = [];\n            for (var system = this._systemList.head; system; system = system.next) {\n                tmpSystems.push(system);\n            }\n            return tmpSystems;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Engine.prototype.addEntity = function (entity) {\n        if (this._entityNames.has(entity.name)) {\n            throw new Error('The entity name ' + entity.name + ' is already in use by another entity.');\n        }\n        this._entityList.add(entity);\n        this._entityNames.add(entity.name, entity);\n        entity.componentAdded.add(this._componentAdded, this);\n        entity.componentRemoved.add(this._componentRemoved, this);\n        entity.nameChanged.add(this._entityNameChanged, this);\n        this._families.forEach(function (nodeObject, family) {\n            family.newEntity(entity);\n        });\n    };\n    Engine.prototype.removeEntity = function (entity) {\n        entity.componentAdded.remove(this._componentAdded, this);\n        entity.componentRemoved.remove(this._componentRemoved, this);\n        entity.nameChanged.remove(this._entityNameChanged, this);\n        this._families.forEach(function (nodeObject, family) {\n            family.removeEntity(entity);\n        });\n        this._entityNames.remove(entity.name);\n        this._entityList.remove(entity);\n    };\n    Engine.prototype.getEntityByName = function (name) {\n        if (this._entityNames.has(name)) {\n            return this._entityNames.getValue(name);\n        }\n        return null;\n    };\n    Engine.prototype.removeAllEntities = function () {\n        while (this._entityList.head) {\n            this.removeEntity(this._entityList.head);\n        }\n    };\n    Engine.prototype.addScene = function (scene) {\n        this._sceneList.add(scene);\n        this._sceneNames.add(scene.name, scene);\n        scene.nameChanged.add(this._sceneNameChanged, this);\n    };\n    Engine.prototype.removeScene = function (scene) {\n        this._sceneList.remove(scene);\n        this._sceneNames.remove(scene.name);\n        scene.nameChanged.remove(this._sceneNameChanged, this);\n    };\n    Engine.prototype.removeAllScenes = function () {\n        while (this._sceneList.head) {\n            this.removeScene(this._sceneList.head);\n        }\n    };\n    Engine.prototype.getSceneByName = function (name) {\n        if (this._sceneNames.has(name)) {\n            return this._sceneNames.getValue(name);\n        }\n        return null;\n    };\n    Engine.prototype.getScene = function (type) {\n        return this._sceneList.get(type);\n    };\n    Engine.prototype.getNodeList = function (nodeClass) {\n        if (this._families.has(nodeClass)) {\n            return this._families.getValue(nodeClass)._nodes;\n        }\n        var family = new this.familyClass(nodeClass, this);\n        this._families.add(nodeClass, family);\n        for (var entity = this._entityList.head; entity; entity = entity.next) {\n            family.newEntity(entity);\n        }\n        return family.nodeList;\n    };\n    Engine.prototype.releaseNodeList = function (nodeClass) {\n        if (this._families.has(nodeClass)) {\n            this._families.getValue(nodeClass).cleanUp();\n        }\n        else {\n            throw new Error('The given nodeClass was not found and can not be released.');\n        }\n        this._families.remove(nodeClass);\n    };\n    Engine.prototype.addSystem = function (system, priority) {\n        system.priority = priority;\n        system.addToEngine(this);\n        this._systemList.add(system);\n    };\n    Engine.prototype.getSystem = function (type) {\n        return this._systemList.get(type);\n    };\n    Engine.prototype.removeSystem = function (system) {\n        this._systemList.remove(system);\n        system.removeFromEngine(this);\n    };\n    Engine.prototype.removeAllSystems = function () {\n        while (this._systemList.head) {\n            this.removeSystem(this._systemList.head);\n        }\n    };\n    Engine.prototype.update = function (time) {\n        this.updating = true;\n        for (var system = this._systemList.head; system; system = system.next) {\n            system.update(time);\n        }\n        this.updating = false;\n        this.updateComplete.dispatch();\n    };\n    Engine.prototype._entityNameChanged = function (entity, oldName) {\n        if (this._entityNames.has(oldName)) {\n            this._entityNames.remove(oldName);\n            this._entityNames.add(entity.name, entity);\n        }\n        else {\n            throw new Error('The given name was not found in the entity list.');\n        }\n    };\n    Engine.prototype._sceneNameChanged = function (scene, oldName) {\n        if (this._sceneNames.has(oldName)) {\n            this._sceneNames.remove(oldName);\n            this._sceneNames.add(scene.name, scene);\n        }\n        else {\n            throw new Error('The given name was not found in the scene list.');\n        }\n    };\n    Engine.prototype._componentAdded = function (entity, componentClass) {\n        this._families.forEach(function (nodeObject, family) {\n            family.componentAddedToEntity(entity, componentClass);\n        });\n    };\n    Engine.prototype._componentRemoved = function (entity, componentClass) {\n        this._families.forEach(function (nodeObject, family) {\n            family.componentRemovedFromEntity(entity, componentClass);\n        });\n    };\n    return Engine;\n})();\nexports.Engine = Engine;\n\n},{\"../utils/Dictionary\":10,\"../utils/Signal\":11,\"./ComponentMatchingFamily\":1,\"./EntityList\":3,\"./SceneList\":6,\"./SystemList\":8}],3:[function(require,module,exports){\nvar EntityList = (function () {\n    function EntityList() {\n    }\n    EntityList.prototype.add = function (entity) {\n        if (!this.head) {\n            this.head = this.tail = entity;\n            entity.next = entity.previous = null;\n        }\n        else {\n            this.tail.next = entity;\n            entity.previous = this.tail;\n            entity.next = null;\n            this.tail = entity;\n        }\n    };\n    EntityList.prototype.remove = function (entity) {\n        if (this.head === entity) {\n            this.head = this.head.next;\n        }\n        if (this.tail === entity) {\n            this.tail = this.tail.previous;\n        }\n        if (entity.previous) {\n            entity.previous.next = entity.next;\n        }\n        if (entity.next) {\n            entity.next.previous = entity.previous;\n        }\n    };\n    EntityList.prototype._removeAll = function () {\n        while (this.head) {\n            var entity = this.head;\n            this.head = this.head.next;\n            entity.previous = null;\n            entity.next = null;\n        }\n        this.tail = null;\n    };\n    return EntityList;\n})();\nexports.EntityList = EntityList;\n\n},{}],4:[function(require,module,exports){\nvar Signal_1 = require('../utils/Signal');\nvar NodeList = (function () {\n    function NodeList() {\n        this.head = null;\n        this.tail = null;\n        this.nodeAdded = new Signal_1.Signal();\n        this.nodeRemoved = new Signal_1.Signal();\n    }\n    NodeList.prototype.add = function (node) {\n        if (!this.head) {\n            this.head = this.tail = node;\n            node.next = node.previous = null;\n        }\n        else {\n            this.tail.next = node;\n            node.previous = this.tail;\n            node.next = null;\n            this.tail = node;\n        }\n        this.nodeAdded.dispatch(node);\n    };\n    NodeList.prototype.remove = function (node) {\n        if (this.head === node) {\n            this.head = this.head.next;\n        }\n        if (this.tail === node) {\n            this.tail = this.tail.previous;\n        }\n        if (node.previous) {\n            node.previous.next = node.next;\n        }\n        if (node.next) {\n            node.next.previous = node.previous;\n        }\n        this.nodeRemoved.dispatch(node);\n    };\n    NodeList.prototype.removeAll = function () {\n        while (this.head) {\n            var node = this.head;\n            this.head = node.next;\n            node.previous = null;\n            node.next = null;\n            this.nodeRemoved.dispatch(node);\n        }\n        this.tail = null;\n    };\n    NodeList.prototype.empty = function () {\n        return this.head === null;\n    };\n    NodeList.prototype.swap = function (node1, node2) {\n        if (node1.previous === node2) {\n            node1.previous = node2.previous;\n            node2.previous = node1;\n            node2.next = node1.next;\n            node1.next = node2;\n        }\n        else if (node2.previous === node1) {\n            node2.previous = node1.previous;\n            node1.previous = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n        }\n        else {\n            var temp = node1.previous;\n            node1.previous = node2.previous;\n            node2.previous = temp;\n            temp = node1.next;\n            node1.next = node2.next;\n            node2.next = temp;\n        }\n        if (this.head === node1) {\n            this.head = node2;\n        }\n        else if (this.head === node2) {\n            this.head = node1;\n        }\n        if (this.tail === node1) {\n            this.tail = node2;\n        }\n        else if (this.tail === node2) {\n            this.tail = node1;\n        }\n        if (node1.previous) {\n            node1.previous.next = node1;\n        }\n        if (node2.previous) {\n            node2.previous.next = node2;\n        }\n        if (node1.next) {\n            node1.next.previous = node1;\n        }\n        if (node2.next) {\n            node2.next.previous = node2;\n        }\n    };\n    NodeList.prototype.insertionSort = function (sortFunction) {\n        if (this.head === this.tail) {\n            return;\n        }\n        var remains = this.head.next;\n        for (var node = remains; node; node = remains) {\n            remains = node.next;\n            for (var other = node.previous; other; other = other.previous) {\n                if (sortFunction(node, other) >= 0) {\n                    if (node !== other.next) {\n                        if (this.tail === node) {\n                            this.tail = node.previous;\n                        }\n                        node.previous.next = node.next;\n                        if (node.next) {\n                            node.next.previous = node.previous;\n                        }\n                        node.next = other.next;\n                        node.previous = other;\n                        node.next.previous = node;\n                        other.next = node;\n                    }\n                    break;\n                }\n            }\n            if (!other) {\n                if (this.tail === node) {\n                    this.tail = node.previous;\n                }\n                node.previous.next = node.next;\n                if (node.next) {\n                    node.next.previous = node.previous;\n                }\n                node.next = this.head;\n                this.head.previous = node;\n                node.previous = null;\n                this.head = node;\n            }\n        }\n    };\n    NodeList.prototype.mergeSort = function (sortFunction) {\n        if (this.head === this.tail) {\n            return;\n        }\n        var lists;\n        var start = this.head;\n        var end;\n        while (start) {\n            end = start;\n            while (end.next && sortFunction(end, end.next) <= 0) {\n                end = end.next;\n            }\n            var next = end.next;\n            start.previous = end.next = null;\n            lists.push(start);\n            start = next;\n        }\n        while (lists.length > 1) {\n        }\n        this.tail = this.head = lists[0];\n        while (this.tail.next) {\n            this.tail = this.tail.next;\n        }\n    };\n    NodeList.prototype._merge = function (head1, head2, sortFunction) {\n        var node;\n        var head;\n        if (sortFunction(head1, head2) <= 0) {\n            head = node = head1;\n            head1 = head1.next;\n        }\n        else {\n            head = node = head2;\n            head2 = head2.next;\n        }\n        while (head1 && head2) {\n            if (sortFunction(head1, head2) <= 0) {\n                node.next = head1;\n                head1.previous = node;\n                node = head1;\n                head1 = head1.next;\n            }\n            else {\n                node.next = head2;\n                head2.previous = node;\n                node = head2;\n                head2 = head2.next;\n            }\n        }\n        if (head1) {\n            node.next = head1;\n            head1.previous = node;\n        }\n        else {\n            node.next = head2;\n            head2.previous = node;\n        }\n        return head;\n    };\n    return NodeList;\n})();\nexports.NodeList = NodeList;\n\n},{\"../utils/Signal\":11}],5:[function(require,module,exports){\nvar NodePool = (function () {\n    function NodePool(nodeClass, components) {\n        this._nodeClass = nodeClass;\n        this._components = components;\n    }\n    NodePool.prototype.get = function () {\n        if (this._tail) {\n            var node = this._tail;\n            this._tail = this._tail.previous;\n            node.previous = null;\n            return node;\n        }\n        else {\n            var newNode = new this._nodeClass;\n            return newNode;\n        }\n    };\n    NodePool.prototype.dispose = function (node) {\n        this._components.forEach(function (componentClass, componentName) {\n            node[componentName] = null;\n        });\n        node.entity = null;\n        node.next = null;\n        node.previous = this._tail;\n        this._tail = node;\n    };\n    NodePool.prototype.cache = function (node) {\n        node.previous = this._cacheTail;\n        this._cacheTail = node;\n    };\n    NodePool.prototype.releaseCache = function () {\n        while (this._cacheTail) {\n            var node = this._cacheTail;\n            this._cacheTail = node.previous;\n            node.next = null;\n            node.previous = this._tail;\n            this._tail = node;\n        }\n    };\n    return NodePool;\n})();\nexports.NodePool = NodePool;\n\n},{}],6:[function(require,module,exports){\nvar SceneList = (function () {\n    function SceneList() {\n    }\n    SceneList.prototype.add = function (scene) {\n        if (!this.head) {\n            this.head = this.tail = scene;\n            scene.next = scene.previous = null;\n        }\n        else {\n            this.tail.next = scene;\n            scene.previous = this.tail;\n            scene.next = null;\n            this.tail = scene;\n        }\n    };\n    SceneList.prototype.remove = function (scene) {\n        if (this.head === scene) {\n            this.head = this.head.next;\n        }\n        if (this.tail === scene) {\n            this.tail = this.tail.previous;\n        }\n        if (scene.previous) {\n            scene.previous.next = scene.next;\n        }\n        if (scene.next) {\n            scene.next.previous = scene.previous;\n        }\n    };\n    SceneList.prototype._removeAll = function () {\n        while (this.head) {\n            var scene = this.head;\n            this.head = this.head.next;\n            scene.previous = null;\n            scene.next = null;\n        }\n        this.tail = null;\n    };\n    SceneList.prototype.get = function (type) {\n        for (var scene = this.head; scene; scene = scene.next) {\n            if (scene.is(type)) {\n                return scene;\n            }\n        }\n        return null;\n    };\n    return SceneList;\n})();\nexports.SceneList = SceneList;\n\n},{}],7:[function(require,module,exports){\nvar System = (function () {\n    function System() {\n        this.previous = null;\n        this.next = null;\n        this.priority = 0;\n    }\n    System.prototype.addToEngine = function (engine) {\n    };\n    System.prototype.removeFromEngine = function (engine) {\n    };\n    System.prototype.update = function (time) {\n    };\n    System.prototype.is = function (type) {\n        return type.prototype.isPrototypeOf(this);\n    };\n    return System;\n})();\nexports.System = System;\nSystem.prototype.previous = null;\nSystem.prototype.next = null;\nSystem.prototype.priority = 0;\n\n},{}],8:[function(require,module,exports){\nvar SystemList = (function () {\n    function SystemList() {\n    }\n    SystemList.prototype.add = function (system) {\n        if (!this.head) {\n            this.head = this.tail = system;\n            system.next = system.previous = null;\n        }\n        else {\n            for (var node = this.tail; node; node = node.previous) {\n                if (node.priority <= system.priority) {\n                    break;\n                }\n            }\n            if (node === this.tail) {\n                this.tail.next = system;\n                system.previous = this.tail;\n                system.next = null;\n                this.tail = system;\n            }\n            else if (!node) {\n                system.next = this.head;\n                system.previous = null;\n                this.head.previous = system;\n                this.head = system;\n            }\n            else {\n                system.next = node.next;\n                system.previous = node;\n                node.next.previous = system;\n                node.next = system;\n            }\n        }\n    };\n    SystemList.prototype.remove = function (system) {\n        if (this.head === system) {\n            this.head = this.head.next;\n        }\n        if (this.tail === system) {\n            this.tail = this.tail.previous;\n        }\n        if (system.previous) {\n            system.previous.next = system.next;\n        }\n        if (system.next) {\n            system.next.previous = system.previous;\n        }\n    };\n    SystemList.prototype.removeAll = function () {\n        while (this.head) {\n            var system = this.head;\n            this.head = this.head.next;\n            system.previous = null;\n            system.next = null;\n        }\n        this.tail = null;\n    };\n    SystemList.prototype.get = function (type) {\n        for (var system = this.head; system; system = system.next) {\n            if (system.is(type)) {\n                return system;\n            }\n        }\n        return null;\n    };\n    return SystemList;\n})();\nexports.SystemList = SystemList;\n\n},{}],9:[function(require,module,exports){\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require('./core/Engine'));\n__export(require('./core/System'));\n\n},{\"./core/Engine\":2,\"./core/System\":7}],10:[function(require,module,exports){\nvar Dictionary = (function () {\n    function Dictionary() {\n        this._keys = [];\n        this._values = [];\n    }\n    Dictionary.prototype.add = function (key, value) {\n        var keyIndex = this.getIndex(key);\n        if (keyIndex >= 0) {\n            this._values[keyIndex] = value;\n        }\n        else {\n            this._keys.push(key);\n            this._values.push(value);\n        }\n    };\n    Dictionary.prototype.remove = function (key) {\n        var keyIndex = this.getIndex(key);\n        if (keyIndex >= 0) {\n            var removedValue = this._values[keyIndex];\n            this._keys.splice(keyIndex, 1);\n            this._values.splice(keyIndex, 1);\n            return removedValue;\n        }\n        else {\n            throw 'Key does not exist';\n        }\n    };\n    Dictionary.prototype.getValue = function (key) {\n        var value = null;\n        var keyIndex = this.getIndex(key);\n        if (keyIndex >= 0) {\n            value = this._values[keyIndex];\n        }\n        return value;\n    };\n    Dictionary.prototype.getIndex = function (testKey) {\n        var i = 0, len = this._keys.length, key;\n        for (; i < len; ++i) {\n            key = this._keys[i];\n            if (key === testKey) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    Dictionary.prototype.has = function (testKey) {\n        var i = 0, len = this._keys.length, key;\n        for (i; i < len; ++i) {\n            key = this._keys[i];\n            if (key === testKey) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Dictionary.prototype.values = function () {\n        var i = 0, len = this._keys.length, key, value;\n        var arValue = [];\n        for (; i < len; ++i) {\n            key = this._keys[i];\n            value = this._values[i];\n            arValue.push(value);\n        }\n        return arValue;\n    };\n    Dictionary.prototype.forEach = function (action) {\n        var i = 0, len = this._keys.length, key, value;\n        for (; i < len; ++i) {\n            key = this._keys[i];\n            value = this._values[i];\n            var breakHere = action(key, value);\n            if (breakHere === 'return') {\n                return false;\n            }\n        }\n        return true;\n    };\n    return Dictionary;\n})();\nexports.Dictionary = Dictionary;\n\n},{}],11:[function(require,module,exports){\nvar SignalBinding_1 = require('./SignalBinding');\nvar Signal = (function () {\n    function Signal() {\n        this._bindings = [];\n        this._prevParams = null;\n        this.memorize = false;\n        this._shouldPropagate = true;\n        this.active = true;\n    }\n    Signal.prototype.validateListener = function (listener, fnName) {\n        if (typeof listener !== 'function') {\n            throw new Error('listener is a required param of {fn}() and should be a Function.'\n                .replace('{fn}', fnName));\n        }\n    };\n    Signal.prototype._registerListener = function (listener, isOnce, listenerContext, priority) {\n        var prevIndex = this._indexOfListener(listener, listenerContext);\n        var binding;\n        if (prevIndex !== -1) {\n            binding = this._bindings[prevIndex];\n            if (binding.isOnce() !== isOnce) {\n                throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once')\n                    + '() the same listener without removing the relationship first.');\n            }\n        }\n        else {\n            binding = new SignalBinding_1.SignalBinding(this, listener, isOnce, listenerContext, priority);\n            this._addBinding(binding);\n        }\n        if (this.memorize && this._prevParams) {\n            binding.execute(this._prevParams);\n        }\n        return binding;\n    };\n    Signal.prototype._addBinding = function (binding) {\n        var n = this._bindings.length;\n        do {\n            --n;\n        } while (this._bindings[n] && binding.priority <= this._bindings[n].priority);\n        this._bindings.splice(n + 1, 0, binding);\n    };\n    Signal.prototype._indexOfListener = function (listener, context) {\n        var n = this._bindings.length;\n        var cur;\n        while (n--) {\n            cur = this._bindings[n];\n            if (cur.getListener() === listener && cur.context === context) {\n                return n;\n            }\n        }\n        return -1;\n    };\n    Signal.prototype.has = function (listener, context) {\n        if (context === void 0) { context = null; }\n        return this._indexOfListener(listener, context) !== -1;\n    };\n    Signal.prototype.add = function (listener, listenerContext, priority) {\n        if (listenerContext === void 0) { listenerContext = null; }\n        if (priority === void 0) { priority = 0; }\n        this.validateListener(listener, 'add');\n        return this._registerListener(listener, false, listenerContext, priority);\n    };\n    Signal.prototype.addOnce = function (listener, listenerContext, priority) {\n        if (listenerContext === void 0) { listenerContext = null; }\n        if (priority === void 0) { priority = 0; }\n        this.validateListener(listener, 'addOnce');\n        return this._registerListener(listener, true, listenerContext, priority);\n    };\n    Signal.prototype.remove = function (listener, context) {\n        if (context === void 0) { context = null; }\n        this.validateListener(listener, 'remove');\n        var i = this._indexOfListener(listener, context);\n        if (i !== -1) {\n            this._bindings[i]._destroy();\n            this._bindings.splice(i, 1);\n        }\n        return listener;\n    };\n    Signal.prototype.removeAll = function () {\n        var n = this._bindings.length;\n        while (n--) {\n            this._bindings[n]._destroy();\n        }\n        this._bindings.length = 0;\n    };\n    Signal.prototype.getNumListeners = function () {\n        return this._bindings.length;\n    };\n    Signal.prototype.halt = function () {\n        this._shouldPropagate = false;\n    };\n    Signal.prototype.dispatch = function () {\n        var paramsArr = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            paramsArr[_i - 0] = arguments[_i];\n        }\n        if (!this.active) {\n            return;\n        }\n        var n = this._bindings.length;\n        var bindings;\n        if (this.memorize) {\n            this._prevParams = paramsArr;\n        }\n        if (!n) {\n            return;\n        }\n        bindings = this._bindings.slice(0);\n        this._shouldPropagate = true;\n        do {\n            n--;\n        } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);\n    };\n    Signal.prototype.forget = function () {\n        this._prevParams = null;\n    };\n    Signal.prototype.dispose = function () {\n        this.removeAll();\n        this._bindings = null;\n        this._prevParams = null;\n    };\n    Signal.prototype.toString = function () {\n        return '[Signal active:' + this.active + ' numListeners:' + this.getNumListeners() + ']';\n    };\n    Signal.VERSION = '1.0.0';\n    return Signal;\n})();\nexports.Signal = Signal;\n\n},{\"./SignalBinding\":12}],12:[function(require,module,exports){\nvar SignalBinding = (function () {\n    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {\n        this.active = true;\n        this.params = null;\n        this._listener = listener;\n        this._isOnce = isOnce;\n        this.context = listenerContext;\n        this._signal = signal;\n        this.priority = priority || 0;\n    }\n    SignalBinding.prototype.execute = function (paramsArr) {\n        var handlerReturn;\n        var params;\n        if (this.active && !!this._listener) {\n            params = this.params ? this.params.concat(paramsArr) : paramsArr;\n            handlerReturn = this._listener.apply(this.context, params);\n            if (this._isOnce) {\n                this.detach();\n            }\n        }\n        return handlerReturn;\n    };\n    SignalBinding.prototype.detach = function () {\n        return this.isBound() ? this._signal.remove(this._listener, this.context) : null;\n    };\n    SignalBinding.prototype.isBound = function () {\n        return (!!this._signal && !!this._listener);\n    };\n    SignalBinding.prototype.isOnce = function () {\n        return this._isOnce;\n    };\n    SignalBinding.prototype.getListener = function () {\n        return this._listener;\n    };\n    SignalBinding.prototype.getSignal = function () {\n        return this._signal;\n    };\n    SignalBinding.prototype._destroy = function () {\n        this._signal = null;\n        this._listener = null;\n        this.context = null;\n    };\n    SignalBinding.prototype.toString = function () {\n        return '[SignalBinding isOnce:' + this._isOnce\n            + ', isBound:' + this.isBound()\n            + ', active:' + this.active + ']';\n    };\n    return SignalBinding;\n})();\nexports.SignalBinding = SignalBinding;\n\n},{}]},{},[9])\n\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n * The default class for managing a NodeList. This class creates the NodeList and adds and removes\n * nodes to/from the list as the entities and the components in the engine change.\n *\n * It uses the basic entity matching pattern of an entity system - entities are added to the list if\n * they contain components matching all the public properties of the node class.\n */\nimport {Node} from './Node';\nimport {NodePool} from './NodePool';\nimport {NodeList} from './NodeList';\nimport {Engine} from './Engine';\nimport {Entity} from './Entity';\nimport {IFamily} from './IFamily';\nimport {Dictionary} from '../utils/Dictionary';\n\nexport class ComponentMatchingFamily implements IFamily {\n    private _nodes:NodeList;\n    private _entities:Dictionary;\n    private _nodeClass;\n    private _components:Dictionary;\n    private _nodePool:NodePool;\n    private _engine:Engine;\n\n    /**\n     * The constructor. Creates a ComponentMatchingFamily to provide a NodeList for the\n     * given node class.\n     *\n     * @param nodeClass The type of node to create and manage a NodeList for.\n     * @param engine The engine that this family is managing teh NodeList for.\n     */\n    constructor(nodeClass:any, engine:Engine) {\n        this._nodeClass = nodeClass;\n        this._engine = engine;\n\n        this._nodes = new NodeList();\n        this._entities = new Dictionary();\n        this._components = new Dictionary();\n\n        var nodeClassPrototype = this._nodeClass.prototype;\n\n        for (var property in nodeClassPrototype) {\n            ///TODO - tidy this up...\n            if (nodeClassPrototype.hasOwnProperty(property) &&\n                property !== 'types' &&\n                property !== 'next' &&\n                property !== 'previous' &&\n                property !== 'constructor' &&\n                property !== 'super' &&\n                property !== 'extend' &&\n                property !== 'entity') {\n                var componentObject = nodeClassPrototype.types[property];\n                this._components.add(componentObject, property);\n            }\n        }\n\n        this._nodePool = new NodePool(this._nodeClass, this._components);\n        this._nodePool.dispose(this._nodePool.get());\n        /*this._nodeClass = nodeClass;\n         this._engine = engine;\n\n         this._nodePool = new silverback.core.NodePool(this._nodeClass);\n         this._nodes = new silverback.core.NodeList();\n         this._entities = new silverback.utils.Dictionary();\n\n         this._components = new silverback.utils.Dictionary();\n         this._nodePool.dispose(this._nodePool.get()); // create a dummy instance to ensure describeType works.\n\n         var nodeClassPrototype = this._nodeClass.prototype;\n\n         for (var property in nodeClassPrototype) {\n         ///TODO - tidy this up...\n         if (nodeClassPrototype.hasOwnProperty(property) &&\n         property !== 'types' &&\n         property !== 'next' &&\n         property !== 'previous' &&\n         property !== 'constructor' &&\n         property !== 'super' &&\n         property !== 'extend' &&\n         property !== 'entity') {\n         var componentObject = nodeClassPrototype.types[property];\n         this._components.add(componentObject, property);\n         }\n         }\n\n         this._init();*/\n    }\n\n    /**\n     * Initialises the class. Creates the nodelist and other tools. Analyses the node to determine\n     * what component types the node requires.\n     */\n    /*private _init()\n     {\n     }*/\n\n    /**\n     * The nodelist managed by this family. This is a reference that remains valid always\n     * since it is retained and reused by Systems that use the list. i.e. we never recreate the list,\n     * we always modify it in place.\n     */\n    public get nodeList():NodeList {\n        return this._nodes;\n    }\n\n    /**\n     * Called by the engine when an entity has been added to it. We check if the entity should be in\n     * this family's NodeList and add it if appropriate.\n     */\n    public newEntity(entity:Entity) {\n        this.addIfMatch(entity);\n    }\n\n    /**\n     * Called by the engine when a component has been added to an entity. We check if the entity is not in\n     * this family's NodeList and should be, and add it if appropriate.\n     */\n    public componentAddedToEntity(entity:Entity, componentClass:() => any) {\n        this.addIfMatch(entity);\n    }\n\n    /**\n     * Called by the engine when a component has been removed from an entity. We check if the removed component\n     * is required by this family's NodeList and if so, we check if the entity is in this this NodeList and\n     * remove it if so.\n     */\n    public componentRemovedFromEntity(entity:Entity, componentClass:() => any) {\n        if (this._components.has(componentClass)) {\n            this.removeIfMatch(entity);\n        }\n    }\n\n    /**\n     * Called by the engine when an entity has been rmoved from it. We check if the entity is in\n     * this family's NodeList and remove it if so.\n     */\n    public removeEntity(entity:Entity) {\n        this.removeIfMatch(entity);\n    }\n\n    /**\n     * If the entity is not in this family's NodeList, tests the components of the entity to see\n     * if it should be in this NodeList and adds it if so.\n     */\n    public addIfMatch(entity:Entity) {\n        if (!this._entities.has(entity)) {\n            var componentClass;\n            if (\n                !this._components.forEach(function (componentClass, componentName) {\n                    if (!entity.has(componentClass)) {\n                        return 'return';\n                    }\n                })\n            ) {\n                return;\n            }\n            var node = this._nodePool.get();\n            node.entity = entity;\n            this._components.forEach(function (componentClass, componentName) {\n                node[componentName] = entity.get(componentClass);\n            });\n            this._entities.add(entity, node);\n            entity.componentRemoved.add(this.componentRemovedFromEntity, this);\n            this._nodes.add(node);\n        }\n        /*if (!this._entities.getValue(entity))\n         {\n         var componentClass : any;\n         for (componentClass in this._components )\n         {\n         if ( !entity.has( componentClass ) )\n         {\n         return;\n         }\n         }\n         var node: silverback.core.Node = this._nodePool.get();\n         node.entity = entity;\n         for (componentClass in this._components )\n         {\n         node[this._components[componentClass]] = entity.get( componentClass );\n         }\n         this._entities.add(entity, node);\n         this._nodes.add( node );\n         }*/\n    }\n\n    /**\n     * Removes the entity if it is in this family's NodeList.\n     */\n    public removeIfMatch(entity:Entity) {\n        if (this._entities.getValue(entity)) {\n            var node:Node = this._entities.getValue(entity);\n            this._entities.remove(entity);\n            this._nodes.remove(node);\n            if (this._engine.updating) {\n                this._nodePool.cache(node);\n                this._engine.updateComplete.add(this._releaseNodePoolCache, this);\n            } else {\n                this._nodePool.dispose(node);\n            }\n        }\n    }\n\n    /**\n     * Releases the nodes that were added to the node pool during this engine update, so they can\n     * be reused.\n     */\n    private _releaseNodePoolCache() {\n        this._engine.updateComplete.remove(this._releaseNodePoolCache);\n        this._nodePool.releaseCache();\n    }\n\n    /**\n     * Removes all nodes from the NodeList.\n     */\n    public cleanUp() {\n        for (var node:Node = this._nodes.head; node; node = node.next) {\n            this._entities.remove(node.entity);\n        }\n        this._nodes.removeAll();\n    }\n}","/**\n * @module Silverback\n * @class Engine\n */\n\n/// <reference path=\"../../typings/tsd.d.ts\" />\n\nimport {Entity} from './Entity';\nimport {EntityList} from './EntityList';\nimport {Scene} from './Scene';\nimport {SceneList} from './SceneList';\nimport {SystemList} from './SystemList';\nimport {NodeList} from './NodeList';\nimport {Dictionary} from '../utils/Dictionary';\nimport {Signal} from '../utils/Signal';\nimport {System} from './System';\nimport {ComponentMatchingFamily} from './ComponentMatchingFamily';\nimport {IFamily} from './IFamily';\n\n/**\n * The Engine class is the central point for creating and managing your game state. Add\n * entities and systems to the engine, and fetch families of nodes from the engine.\n */\nexport class Engine {\n\n    private _entityNames:Dictionary;\n    private _entityList:EntityList;\n    private _sceneList:SceneList;\n    private _sceneNames:Dictionary;\n    private _systemList:SystemList;\n    private _families:Dictionary;\n\n    private _tempArray;\n    /**\n     * Indicates if the engine is currently in its update loop.\n     */\n    public updating:boolean;\n\n    /**\n     * Dispatched when the update loop ends. If you want to add and remove systems from the\n     * engine it is usually best not to do so during the update loop. To avoid this you can\n     * listen for this signal and make the change when the signal is dispatched.\n     */\n    public updateComplete:Signal;\n\n    /**\n     * The class used to manage node lists. In most cases the default class is sufficient\n     * but it is exposed here so advanced developers can choose to create and use a\n     * different implementation.\n     *\n     * The class must implement the Family interface.\n     */\n    public familyClass;\n\n    constructor() {\n        this._entityList = new EntityList();\n        this._entityNames = new Dictionary();\n        this._sceneNames = new Dictionary();\n        this._sceneList = new SceneList();\n        this._systemList = new SystemList();\n        this._families = new Dictionary();\n        this.updateComplete = new Signal();\n\n        this.familyClass = ComponentMatchingFamily;\n    }\n\n    /**\n     * Returns an array containing all the entities in the engine.\n     */\n    public get entities():Array<Entity> {\n        var tmpEntities = [];\n        for(var entity = this._entityList.head; entity; entity = entity.next) {\n            tmpEntities.push(entity);\n        }\n        return tmpEntities;\n    }\n\n    /**\n     * Returns an array containing all the scenes in the engine.\n     */\n    public get scenes():Array<Scene> {\n        var tmpScenes = [];\n        for(var scene = this._sceneList.head; scene; scene = scene.next) {\n            tmpScenes.push(scene);\n        }\n        return tmpScenes;\n    }\n\n    /**\n     * Returns an array containing all the systems in the engine.\n     */\n    public get systems():Array<System> {\n        var tmpSystems = [];\n        for (var system = this._systemList.head; system; system = system.next) {\n            tmpSystems.push(system);\n        }\n        return tmpSystems;\n    }\n\n    /**\n     * Add an entity to the engine.\n     *\n     * @param entity The entity to add.\n     */\n    public addEntity(entity:Entity):void {\n        if(this._entityNames.has(entity.name)) {\n            throw new Error('The entity name ' + entity.name + ' is already in use by another entity.');\n        }\n        this._entityList.add(entity);\n        this._entityNames.add(entity.name, entity);\n        entity.componentAdded.add(this._componentAdded, this);\n        entity.componentRemoved.add(this._componentRemoved, this);\n        entity.nameChanged.add(this._entityNameChanged, this);\n\n        this._families.forEach((nodeObject, family:IFamily) => {\n                family.newEntity(entity);\n            }\n        );\n    }\n\n    /**\n     * Remove an entity from the engine.\n     *\n     * @param entity The entity to remove.\n     */\n    public removeEntity(entity: Entity):void {\n        entity.componentAdded.remove(this._componentAdded, this);\n        entity.componentRemoved.remove(this._componentRemoved, this);\n        entity.nameChanged.remove(this._entityNameChanged, this);\n\n        this._families.forEach((nodeObject, family: IFamily) => {\n                family.removeEntity(entity);\n            }\n        );\n        this._entityNames.remove(entity.name);\n        this._entityList.remove(entity);\n    }\n\n    /**\n     * Get an entity based on its name.\n     *\n     * @param name The name of the entity\n     * @return The entity, or null if no entity with that name exists on the engine\n     */\n    public getEntityByName(name:string):Entity {\n        if(this._entityNames.has(name)) {\n            return this._entityNames.getValue(name);\n        }\n        return null;\n    }\n\n    /**\n     * Remove all entities from the engine.\n     */\n    public removeAllEntities():void {\n        while (this._entityList.head) {\n            this.removeEntity(this._entityList.head);\n        }\n    }\n\n    /**\n     * Add an scene to the engine.\n     *\n     * @param scene The scene to add.\n     */\n    public addScene(scene:Scene):void {\n        this._sceneList.add(scene);\n        this._sceneNames.add(scene.name, scene);\n        scene.nameChanged.add(this._sceneNameChanged, this);\n\n    }\n\n    /**\n     * Remove an scene from the engine.\n     *\n     * @param scene The scene to remove.\n     */\n    public removeScene(scene:Scene):void {\n        this._sceneList.remove( scene );\n        this._sceneNames.remove(scene.name);\n        scene.nameChanged.remove(this._sceneNameChanged, this);\n    }\n\n    /**\n     * Remove all scenes from the engine.\n     */\n    public removeAllScenes():void {\n        while (this._sceneList.head) {\n            this.removeScene(this._sceneList.head);\n        }\n    }\n\n    /**\n     * Get an scene based on its name.\n     *\n     * @param name The name of the scene\n     * @return The scene, or null if no scene with that name exists on the engine\n     */\n    public getSceneByName(name:string):Scene {\n        if(this._sceneNames.has(name)) {\n            return this._sceneNames.getValue(name);\n        }\n        return null;\n    }\n\n    /**\n     * Get the scene instance of a particular type from within the engine.\n     *\n     * @param type The type of scene\n     * @return The instance of the scene type that is in the engine, or\n     * null if no scene of this type are in the engine.\n     */\n    public getScene(type):Scene {\n        return this._sceneList.get(type);\n    }\n\n    /**\n     * Get a collection of nodes from the engine, based on the type of the node required.\n     *\n     * <p>The engine will create the appropriate NodeList if it doesn't already exist and\n     * will keep its contents up to date as entities are added to and removed from the\n     * engine.</p>\n     *\n     * <p>If a NodeList is no longer required, release it with the releaseNodeList method.</p>\n     *\n     * @param nodeClass The type of node required.\n     * @return A linked list of all nodes of this type from all entities in the engine.\n     */\n    public getNodeList(nodeClass):NodeList {\n        if(this._families.has(nodeClass)) {\n            return this._families.getValue(nodeClass)._nodes;\n        }\n        var family = new this.familyClass(nodeClass, this);\n        this._families.add(nodeClass, family);\n        for (var entity:Entity = this._entityList.head; entity; entity = entity.next) {\n            family.newEntity(entity);\n        }\n        return family.nodeList;\n    }\n\n    /**\n     * If a NodeList is no longer required, this method will stop the engine updating\n     * the list and will release all references to the list within the framework\n     * classes, enabling it to be garbage collected.\n     *\n     * <p>It is not essential to release a list, but releasing it will free\n     * up memory and processor resources.</p>\n     *\n     * @param nodeClass The type of the node class if the list to be released.\n     */\n    public releaseNodeList(nodeClass) {\n        if(this._families.has(nodeClass)) {\n            this._families.getValue(nodeClass).cleanUp();\n        } else {\n            throw new Error('The given nodeClass was not found and can not be released.');\n        }\n        this._families.remove(nodeClass);\n    }\n\n    /**\n     * Add a system to the engine, and set its priority for the order in which the\n     * systems are updated by the engine update loop.\n     *\n     * <p>The priority dictates the order in which the systems are updated by the engine update\n     * loop. Lower numbers for priority are updated first. i.e. a priority of 1 is\n     * updated before a priority of 2.</p>\n     *\n     * @param system The system to add to the engine.\n     * @param priority The priority for updating the systems during the engine loop. A\n     * lower number means the system is updated sooner.\n     */\n    public addSystem(system:System, priority:number) {\n        system.priority = priority;\n        system.addToEngine(this);\n        this._systemList.add(system);\n    }\n\n    /**\n     * Get the system instance of a particular type from within the engine.\n     *\n     * @param type The type of system\n     * @return The instance of the system type that is in the engine, or\n     * null if no systems of this type are in the engine.\n     */\n    public getSystem(type):System {\n        return this._systemList.get(type);\n    }\n\n    /**\n     * Remove a system from the engine.\n     *\n     * @param system The system to remove from the engine.\n     */\n    public removeSystem(system:System) {\n        this._systemList.remove(system);\n        system.removeFromEngine(this);\n    }\n\n    /**\n     * Remove all systems from the engine.\n     */\n    public removeAllSystems():void {\n        while(this._systemList.head) {\n            this.removeSystem(this._systemList.head);\n        }\n    }\n\n    /**\n     * Update the engine. This causes the engine update loop to run, calling update on all the\n     * systems in the engine.\n     *\n     * @time The duration, in seconds, of this update step.\n     */\n    public update(time:number):void {\n        this.updating = true;\n        for (var system:System = this._systemList.head; system; system = system.next) {\n            system.update(time);\n        }\n        this.updating = false;\n        this.updateComplete.dispatch();\n    }\n\n    /**\n     * @private\n     */\n    private _entityNameChanged(entity:Entity, oldName:string):void {\n        if(this._entityNames.has(oldName)) {\n            this._entityNames.remove(oldName);\n            this._entityNames.add(entity.name, entity);\n        } else {\n            throw new Error('The given name was not found in the entity list.');\n        }\n    }\n\n    /**\n     * @private\n     */\n    private _sceneNameChanged(scene:Scene, oldName:string):void {\n        if(this._sceneNames.has(oldName)) {\n            this._sceneNames.remove(oldName);\n            this._sceneNames.add(scene.name, scene);\n        } else {\n            throw new Error('The given name was not found in the scene list.');\n        }\n    }\n\n    /**\n     * @private\n     */\n    private _componentAdded(entity:Entity, componentClass:() => any):void {\n        this._families.forEach((nodeObject, family:IFamily) => {\n                family.componentAddedToEntity(entity, componentClass);\n            }\n        );\n    }\n\n    /**\n     * @private\n     */\n    private _componentRemoved(entity:Entity, componentClass:() => any):void {\n        this._families.forEach((nodeObject, family:IFamily) => {\n                family.componentRemovedFromEntity(entity, componentClass);\n            }\n        );\n    }\n}","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n * An export class for a linked list of entities. Used inside the framework for\n * managing the entities.\n */\n\nimport {Entity} from './Entity';\n\nexport class EntityList {\n\n    public head:Entity;\n    public tail:Entity;\n\n    public add(entity:Entity) {\n        if (!this.head) {\n            this.head = this.tail = entity;\n            entity.next = entity.previous = null;\n        } else {\n            this.tail.next = entity;\n            entity.previous = this.tail;\n            entity.next = null;\n            this.tail = entity;\n        }\n    }\n\n    public remove(entity:Entity) {\n        if (this.head === entity) {\n            this.head = this.head.next;\n        }\n        if (this.tail === entity) {\n            this.tail = this.tail.previous;\n        }\n\n        if (entity.previous) {\n            entity.previous.next = entity.next;\n        }\n\n        if (entity.next) {\n            entity.next.previous = entity.previous;\n        }\n        // N.B. Don't set node.next and node.previous to null because that will break the list iteration if node is\n        // the current node in the iteration.\n    }\n\n    private _removeAll() {\n        while (this.head) {\n            var entity:Entity = this.head;\n            this.head = this.head.next;\n            entity.previous = null;\n            entity.next = null;\n        }\n        this.tail = null;\n    }\n}","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n\n/**\n * A collection of nodes.\n *\n * <p>Systems within the engine access the components of entities via NodeLists. A NodeList contains\n * a node for each Entity in the engine that has all the components required by the node. To iterate\n * over a NodeList, start from the head and step to the next on each loop, until the returned value\n * is null.</p>\n *\n * <p>for( var node : Node = nodeList.head; node; node = node.next )\n * {\n\t *   // do stuff\n\t * }</p>\n *\n * <p>It is safe to remove items from a nodelist during the loop. When a Node is removed form the\n * NodeList it's previous and next properties still point to the nodes that were before and after\n * it in the NodeList just before it was removed.</p>\n */\n\nimport {Node} from './Node';\nimport {Signal} from '../utils/Signal';\n\nexport class NodeList {\n    /**\n     * The first item in the node list, or null if the list contains no nodes.\n     */\n    public head:any = null;\n    /**\n     * The last item in the node list, or null if the list contains no nodes.\n     */\n    public tail:any = null;\n\n    /**\n     * A signal that is dispatched whenever a node is added to the node list.\n     *\n     * <p>The signal will pass a single parameter to the listeners - the node that was added.</p>\n     */\n    public nodeAdded:Signal;\n    /**\n     * A signal that is dispatched whenever a node is removed from the node list.\n     *\n     * <p>The signal will pass a single parameter to the listeners - the node that was removed.</p>\n     */\n    public nodeRemoved:Signal;\n\n    constructor() {\n        this.nodeAdded = new Signal();\n        this.nodeRemoved = new Signal();\n    }\n\n    public add(node:Node):void {\n        if (!this.head) {\n            this.head = this.tail = node;\n            node.next = node.previous = null;\n        } else {\n            this.tail.next = node;\n            node.previous = this.tail;\n            node.next = null;\n            this.tail = node;\n        }\n        this.nodeAdded.dispatch(node);\n    }\n\n    public remove(node:Node) {\n        if (this.head === node) {\n            this.head = this.head.next;\n        }\n        if (this.tail === node) {\n            this.tail = this.tail.previous;\n        }\n        if (node.previous) {\n            node.previous.next = node.next;\n        }\n        if (node.next) {\n            node.next.previous = node.previous;\n        }\n        this.nodeRemoved.dispatch(node);\n        // N.B. Don't set node.next and node.previous to null because that will break the list iteration if node is\n        // the current node in the iteration.\n    }\n\n    public removeAll() {\n        while (this.head) {\n            var node:Node = this.head;\n            this.head = node.next;\n            node.previous = null;\n            node.next = null;\n            this.nodeRemoved.dispatch(node);\n        }\n        this.tail = null;\n    }\n\n    /**\n     * true if the list is empty, false otherwise.\n     */\n    public empty():boolean {\n        return this.head === null;\n    }\n\n    /**\n     * Swaps the positions of two nodes in the list. Useful when sorting a list.\n     */\n    public swap(node1:Node, node2:Node) {\n        if (node1.previous === node2) {\n            node1.previous = node2.previous;\n            node2.previous = node1;\n            node2.next = node1.next;\n            node1.next = node2;\n        } else if (node2.previous === node1) {\n            node2.previous = node1.previous;\n            node1.previous = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n        } else {\n            var temp:Node = node1.previous;\n            node1.previous = node2.previous;\n            node2.previous = temp;\n            temp = node1.next;\n            node1.next = node2.next;\n            node2.next = temp;\n        }\n\n        if (this.head === node1) {\n            this.head = node2;\n        } else if (this.head === node2) {\n            this.head = node1;\n        }\n        if (this.tail === node1) {\n            this.tail = node2;\n        } else if (this.tail === node2) {\n            this.tail = node1;\n        }\n\n        if (node1.previous) {\n            node1.previous.next = node1;\n        }\n        if (node2.previous) {\n            node2.previous.next = node2;\n        }\n        if (node1.next) {\n            node1.next.previous = node1;\n        }\n        if (node2.next) {\n            node2.next.previous = node2;\n        }\n    }\n\n    /**\n     * Performs an insertion sort on the node list. In general, insertion sort is very efficient with short lists\n     * and with lists that are mostly sorted, but is inefficient with large lists that are randomly ordered.\n     *\n     * <p>The sort function takes two nodes and returns a Number.</p>\n     *\n     * <p><code>function sortFunction( node1 : MockNode, node2 : MockNode ) :number</code></p>\n     *\n     * <p>If the returned number is less than zero, the first node should be before the second. If it is greater\n     * than zero the second node should be before the first. If it is zero the order of the nodes doesn't matter\n     * and the original order will be retained.</p>\n     *\n     * <p>This insertion sort implementation runs in place so no objects are created during the sort.</p>\n     */\n    public insertionSort(sortFunction) {\n        if (this.head === this.tail) {\n            return;\n        }\n        var remains:Node = this.head.next;\n        for (var node:Node = remains; node; node = remains) {\n            remains = node.next;\n            for (var other:Node = node.previous; other; other = other.previous) {\n                if (sortFunction(node, other) >= 0) {\n                    // move node to after other\n                    if (node !== other.next) {\n                        // remove from place\n                        if (this.tail === node) {\n                            this.tail = node.previous;\n                        }\n                        node.previous.next = node.next;\n                        if (node.next) {\n                            node.next.previous = node.previous;\n                        }\n                        // insert after other\n                        node.next = other.next;\n                        node.previous = other;\n                        node.next.previous = node;\n                        other.next = node;\n                    }\n                    break; // exit the inner for loop\n                }\n            }\n            if (!other) { // the node belongs at the start of the list\n                // remove from place\n                if (this.tail === node) {\n                    this.tail = node.previous;\n                }\n                node.previous.next = node.next;\n                if (node.next) {\n                    node.next.previous = node.previous;\n                }\n                // insert at head\n                node.next = this.head;\n                this.head.previous = node;\n                node.previous = null;\n                this.head = node;\n            }\n        }\n    }\n\n    /**\n     * Performs a merge sort on the node list. In general, merge sort is more efficient than insertion sort\n     * with long lists that are very unsorted.\n     *\n     * <p>The sort function takes two nodes and returns a Number.</p>\n     *\n     * <p><code>function sortFunction( node1 : MockNode, node2 : MockNode ) :number</code></p>\n     *\n     * <p>If the returned number is less than zero, the first node should be before the second. If it is greater\n     * than zero the second node should be before the first. If it is zero the order of the nodes doesn't matter.</p>\n     *\n     * <p>This merge sort implementation creates and uses a single Vector during the sort operation.</p>\n     */\n    public mergeSort(sortFunction) {\n        if (this.head === this.tail) {\n            return;\n        }\n        //var lists: Vector.<Node> = new Vector.< Node >;\n        var lists:any;\n        // disassemble the list\n        var start:Node = this.head;\n        var end:Node;\n        while (start) {\n            end = start;\n            while (end.next && sortFunction(end, end.next) <= 0) {\n                end = end.next;\n            }\n            var next:Node = end.next;\n            start.previous = end.next = null;\n            lists.push(start);\n            start = next;\n        }\n        // reassemble it in order\n        while (lists.length > 1) {\n            //TODO VECTOR CLASS\n            //lists.push( merge( lists.shift(), lists.shift(), sortFunction ) );\n        }\n        // find the tail\n        this.tail = this.head = lists[0];\n        while (this.tail.next) {\n            this.tail = this.tail.next;\n        }\n    }\n\n    private _merge(head1:Node, head2:Node, sortFunction):Node {\n        var node:Node;\n        var head:Node;\n        if (sortFunction(head1, head2) <= 0) {\n            head = node = head1;\n            head1 = head1.next;\n        } else {\n            head = node = head2;\n            head2 = head2.next;\n        }\n        while (head1 && head2) {\n            if (sortFunction(head1, head2) <= 0) {\n                node.next = head1;\n                head1.previous = node;\n                node = head1;\n                head1 = head1.next;\n            } else {\n                node.next = head2;\n                head2.previous = node;\n                node = head2;\n                head2 = head2.next;\n            }\n        }\n        if (head1) {\n            node.next = head1;\n            head1.previous = node;\n        } else {\n            node.next = head2;\n            head2.previous = node;\n        }\n        return head;\n    }\n}","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n * This export class maintains a pool of deleted nodes for reuse by the framework. This reduces the overhead\n * from object creation and garbage collection.\n *\n * Because nodes may be deleted from a NodeList while in use, by deleting Nodes from a NodeList\n * while iterating through the NodeList, the pool also maintains a cache of nodes that are added to the pool\n * but should not be reused yet. They are then released into the pool by calling the releaseCache method.\n */\nimport {Node} from './Node';\n\nexport class NodePool {\n    private _tail:Node;\n    private _nodeClass;\n    private _cacheTail:Node;\n    private _components;\n\n    /**\n     * Creates a pool for the given node class.\n     */\n    constructor(nodeClass, components) {\n        this._nodeClass = nodeClass;\n        this._components = components;\n    }\n\n    /**\n     * Fetches a node from the pool.\n     */\n    public get() {\n        if (this._tail) {\n            var node = this._tail;\n            this._tail = this._tail.previous;\n            node.previous = null;\n            return node;\n        } else {\n            var newNode = new this._nodeClass;\n            return newNode;\n        }\n    }\n\n    /**\n     * Adds a node to the pool.\n     */\n    public dispose(node:Node) {\n        this._components.forEach(function (componentClass, componentName) {\n            node[componentName] = null;\n        });\n        node.entity = null;\n        node.next = null;\n        node.previous = this._tail;\n        this._tail = node;\n    }\n\n    /**\n     * Adds a node to the cache\n     */\n    public cache(node:Node) {\n        node.previous = this._cacheTail;\n        this._cacheTail = node;\n    }\n\n    /**\n     * Releases all nodes from the cache into the pool\n     */\n    public releaseCache() {\n        while (this._cacheTail) {\n            var node:Node = this._cacheTail;\n            this._cacheTail = node.previous;\n            node.next = null;\n            node.previous = this._tail;\n            this._tail = node;\n        }\n    }\n}","/// <reference path=\"../../typings/tsd.d.ts\" />\n\nimport {Scene} from './Scene';\n\nexport class SceneList {\n    public head:Scene;\n    public tail:Scene;\n\n    public add(scene:Scene) {\n        if (!this.head) {\n            this.head = this.tail = scene;\n            scene.next = scene.previous = null;\n        } else {\n            this.tail.next = scene;\n            scene.previous = this.tail;\n            scene.next = null;\n            this.tail = scene;\n        }\n    }\n\n    public remove(scene:Scene) {\n        if (this.head === scene) {\n            this.head = this.head.next;\n        }\n        if (this.tail === scene) {\n            this.tail = this.tail.previous;\n        }\n\n        if (scene.previous) {\n            scene.previous.next = scene.next;\n        }\n\n        if (scene.next) {\n            scene.next.previous = scene.previous;\n        }\n    }\n\n    private _removeAll() {\n        while (this.head) {\n            var scene:Scene = this.head;\n            this.head = this.head.next;\n            scene.previous = null;\n            scene.next = null;\n        }\n        this.tail = null;\n    }\n\n    public get(type):Scene {\n        for (var scene = this.head; scene; scene = scene.next) {\n            if (scene.is(type)) {\n                return scene;\n            }\n        }\n        return null;\n    }\n}","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n * The base class for a system.\n *\n * <p>A system is part of the core functionality of the game. After a system is added to the engine, its\n * update method will be called on every frame of the engine. When the system is removed from the engine,\n * the update method is no longer called.</p>\n *\n * <p>The aggregate of all systems in the engine is the functionality of the game, with the update\n * methods of those systems collectively constituting the engine update loop. Systems generally operate on\n * node lists - collections of nodes. Each node contains the components from an entity in the engine\n * that match the node.</p>\n */\nexport class System {\n\n    /**\n     * Used internally to manage the list of systems within the engine. The previous system in the list.\n     */\n    public previous:System = null;\n\n    /**\n     * Used internally to manage the list of systems within the engine. The next system in the list.\n     */\n    public next:System = null;\n\n    /**\n     * Used internally to hold the priority of this system within the system list. This is\n     * used to order the systems so they are updated in the correct order.\n     */\n    public priority:number = 0;\n\n\n    /**\n     * Called just after the system is added to the engine, before any calls to the update method.\n     * Override this method to add your own functionality.\n     *\n     * @param engine The engine the system was added to.\n     */\n    public addToEngine(engine:any):void {\n        /* Empty function */\n    }\n\n    /**\n     * Called just after the system is removed from the engine, after all calls to the update method.\n     * Override this method to add your own functionality.\n     *\n     * @param engine The engine the system was removed from.\n     */\n    public removeFromEngine(engine:any):void {\n        /* Empty function */\n    }\n\n    /**\n     * After the system is added to the engine, this method is called every frame until the system\n     * is removed from the engine. Override this method to add your own functionality.\n     *\n     * <p>If you need to perform an action outside of the update loop (e.g. you need to change the\n     * systems in the engine and you don't want to do it while they're updating) add a listener to\n     * the engine's updateComplete signal to be notified when the update loop completes.</p>\n     *\n     * @param time The duration, in seconds, of the frame.\n     */\n    public update(time:number) {\n        /* Empty function */\n    }\n\n    public is(type) {\n        return type.prototype.isPrototypeOf(this);\n    }\n}\n\nSystem.prototype.previous = null;\nSystem.prototype.next = null;\nSystem.prototype.priority = 0;\n","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n * Used internally, this is an ordered list of Systems for use by the engine update loop.\n */\n\nimport {System} from './System';\n\nexport class SystemList {\n\n    public head:System;\n    public tail:System;\n\n    public add(system:System) {\n        if (!this.head) {\n            this.head = this.tail = system;\n            system.next = system.previous = null;\n        } else {\n            for (var node = this.tail; node; node = node.previous) {\n                if (node.priority <= system.priority) {\n                    break;\n                }\n            }\n            if (node === this.tail) {\n                this.tail.next = system;\n                system.previous = this.tail;\n                system.next = null;\n                this.tail = system;\n            } else if (!node) {\n                system.next = this.head;\n                system.previous = null;\n                this.head.previous = system;\n                this.head = system;\n            } else {\n                system.next = node.next;\n                system.previous = node;\n                node.next.previous = system;\n                node.next = system;\n            }\n        }\n    }\n\n    public remove(system:System) {\n        if (this.head === system) {\n            this.head = this.head.next;\n        }\n        if (this.tail === system) {\n            this.tail = this.tail.previous;\n        }\n\n        if (system.previous) {\n            system.previous.next = system.next;\n        }\n\n        if (system.next) {\n            system.next.previous = system.previous;\n        }\n    }\n\n    public removeAll() {\n        while (this.head) {\n            var system = this.head;\n            this.head = this.head.next;\n            system.previous = null;\n            system.next = null;\n        }\n        this.tail = null;\n    }\n\n    public get(type):System {\n        for (var system = this.head; system; system = system.next) {\n            if (system.is(type)) {\n                return system;\n            }\n        }\n        return null;\n    }\n}","/**\n * @author       Stefan Herndlbauer <sherndlbauer@gorillabyte.com>\n * @copyright    2015 Gorillabyte\n * @license      {@link http://repo.gorillabyte.com/cos/silverback/blob/master/README.md|LGPL License}\n *\n * */\n\n // Core components of the engine\nexport * from './core/Engine';\nexport * from './core/System';\n\n","/// <reference path=\"../../typings/tsd.d.ts\" />\n\nexport class Dictionary {\n\n    private _keys: any[];\n    private _values: any[];\n\n    constructor() {\n        this._keys = [];\n        this._values = [];\n    }\n\n    public add(key, value) {\n        var keyIndex = this.getIndex(key);\n        if (keyIndex >= 0) {\n            this._values[keyIndex] = value;\n        } else {\n            this._keys.push(key);\n            this._values.push(value);\n        }\n    }\n\n    public remove(key): any {\n        var keyIndex = this.getIndex(key);\n        if (keyIndex >= 0) {\n            var removedValue = this._values[keyIndex];\n            this._keys.splice(keyIndex, 1);\n            this._values.splice(keyIndex, 1);\n            return removedValue;\n        } else {\n            throw 'Key does not exist';\n        }\n    }\n\n    public getValue(key) {\n        var value = null;\n        var keyIndex = this.getIndex(key);\n        if (keyIndex >= 0) {\n            value = this._values[keyIndex];\n        }\n        return value;\n    }\n\n    public getIndex(testKey) {\n        var i = 0,\n            len = this._keys.length,\n            key;\n        for (; i < len; ++i) {\n            key = this._keys[i];\n            if (key === testKey) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public has(testKey) {\n        var i = 0,\n            len = this._keys.length,\n            key;\n        for (i; i < len; ++i) {\n            key = this._keys[i];\n            if (key === testKey) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public values(): any[] {\n        var i = 0,\n            len = this._keys.length,\n            key,\n            value;\n        var arValue: any[] = [];\n\n        for (; i < len; ++i) {\n            key = this._keys[i];\n            value = this._values[i];\n            arValue.push(value);\n        }\n        return arValue;\n    }\n\n    public forEach(action) {\n        var i = 0,\n            len = this._keys.length,\n            key,\n            value;\n\n        for (; i < len; ++i) {\n            key = this._keys[i];\n            value = this._values[i];\n            var breakHere = action(key, value);\n            if (breakHere === 'return') {\n                return false;\n            }\n        }\n        return true;\n    }\n}","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n *\tObject that represents a binding between a Signal and a listener function. Released under the MIT license\n *\thttp://millermedeiros.github.com/js-signals/\n *\n *\t@author \tStefan Herndlbauer, 2015, Code refactoring and improvements\n *\t@author \tRichard Davey, 2013, TypeScript conversion\n *\t@author\t\tMiller Medeiros, 2012, JS Signals\n *\t@author\t\tRobert Penner, 2009, AS Signals\n *\n *  @url        http://www.gorillabyte.com\n */\n\nimport {SignalBinding} from './SignalBinding';\n\nexport class Signal {\n\n    /**\n     * @property _bindings\n     * @type Array\n     * @private\n     */\n    private _bindings:SignalBinding[] = [];\n\n    /**\n     * @property _prevParams\n     * @type any\n     * @private\n     */\n    private _prevParams = null;\n\n    /**\n     * Signals Version Number\n     * @property VERSION\n     * @type string\n     * @const\n     */\n    public static VERSION:string = '1.0.0';\n\n    /**\n     * If Signal should keep record of previously dispatched parameters and\n     * automatically execute listener during `add()`/`addOnce()` if Signal was\n     * already dispatched before.\n     * @type boolean\n     */\n    public memorize:boolean = false;\n\n    /**\n     * @type boolean\n     * @private\n     */\n    private _shouldPropagate:boolean = true;\n\n    /**\n     * If Signal is active and should broadcast events.\n     * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch,\n     * if you want to stop the propagation of a signal use `halt()` instead.</p>\n     * @type boolean\n     */\n    public active:boolean = true;\n\n    /**\n     * @method validateListener\n     * @param {Any} listener\n     * @param {Any} fnName\n     */\n    public validateListener(listener, fnName) {\n\n        if (typeof listener !== 'function') {\n            throw new Error('listener is a required param of {fn}() and should be a Function.'\n                .replace('{fn}', fnName));\n        }\n\n    }\n\n    /**\n     * @param {Function} listener\n     * @param {boolean} isOnce\n     * @param {Object} [listenerContext]\n     * @param {Number} [priority]\n     * @return {SignalBinding}\n     * @private\n     */\n    private _registerListener(listener, isOnce:boolean, listenerContext, priority:number):SignalBinding {\n        var prevIndex:number = this._indexOfListener(listener, listenerContext);\n        var binding:SignalBinding;\n\n        if (prevIndex !== -1) {\n            binding = this._bindings[prevIndex];\n\n            if (binding.isOnce() !== isOnce) {\n                throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once')\n                    + '() the same listener without removing the relationship first.');\n            }\n        } else {\n            binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);\n\n            this._addBinding(binding);\n        }\n\n        if (this.memorize && this._prevParams) {\n            binding.execute(this._prevParams);\n        }\n        return binding;\n    }\n\n    /**\n     * @method _addBinding\n     * @param {SignalBinding} binding\n     * @private\n     */\n    private _addBinding(binding:SignalBinding) {\n        //simplified insertion sort\n        var n:number = this._bindings.length;\n\n        do {\n            --n;\n        } while (this._bindings[n] && binding.priority <= this._bindings[n].priority);\n\n        this._bindings.splice(n + 1, 0, binding);\n    }\n\n    /**\n     * @method _indexOfListener\n     * @param {Function} listener\n     * @param {Function} context\n     * @return {number}\n     * @private\n     */\n    private _indexOfListener(listener, context):number {\n        var n:number = this._bindings.length;\n        var cur:SignalBinding;\n\n        while (n--) {\n            cur = this._bindings[n];\n\n            if (cur.getListener() === listener && cur.context === context) {\n                return n;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Check if listener was attached to Signal.\n     * @param {Function} listener\n     * @param {Object} [context]\n     * @return {boolean} if Signal has the specified listener.\n     */\n    public has(listener, context:any = null):boolean {\n        return this._indexOfListener(listener, context) !== -1;\n    }\n\n    /**\n     * Add a listener to the signal.\n     * @param {Function} listener Signal handler function.\n     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent\n     * the `this` variable inside listener function).\n     * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will\n     * be executed before listeners with lower priority. Listeners with same priority level will be executed at\n     * the same order as they were added. (default = 0)\n     * @return {SignalBinding} An Object representing the binding between the Signal and listener.\n     */\n    public add(listener, listenerContext:any = null, priority:number = 0):SignalBinding {\n        this.validateListener(listener, 'add');\n        return this._registerListener(listener, false, listenerContext, priority);\n    }\n\n    /**\n     * Add listener to the signal that should be removed after first execution (will be executed only once).\n     * @param {Function} listener Signal handler function.\n     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent\n     * the `this` variable inside listener function).\n     * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be\n     * executed before listeners with lower priority. Listeners with same priority level will be executed at the\n     * same order as they were added. (default = 0)\n     * @return {SignalBinding} An Object representing the binding between the Signal and listener.\n     */\n    public addOnce(listener, listenerContext:any = null, priority:number = 0):SignalBinding {\n        this.validateListener(listener, 'addOnce');\n        return this._registerListener(listener, true, listenerContext, priority);\n    }\n\n    /**\n     * Remove a single listener from the dispatch queue.\n     * @param {Function} listener Handler function that should be removed.\n     * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing\n     * in a different context).\n     * @return {Function} Listener handler function.\n     */\n    public remove(listener, context:any = null) {\n        this.validateListener(listener, 'remove');\n        var i:number = this._indexOfListener(listener, context);\n\n        if (i !== -1) {\n            this._bindings[i]._destroy(); //no reason to a mSignalBinding.SignalBinding exist if it isn't attached\n            // to a signal\n            this._bindings.splice(i, 1);\n        }\n\n        return listener;\n    }\n\n    /**\n     * Remove all listeners from the Signal.\n     */\n    public removeAll() {\n        var n:number = this._bindings.length;\n\n        while (n--) {\n            this._bindings[n]._destroy();\n        }\n        this._bindings.length = 0;\n    }\n\n    /**\n     * @return {number} Number of listeners attached to the Signal.\n     */\n    public getNumListeners():number {\n        return this._bindings.length;\n    }\n\n    /**\n     * Stop propagation of the event, blocking the dispatch to next listeners on the queue.\n     * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch\n     * won't affect signal broadcast.</p>\n     * @see Signal.prototype.disable\n     */\n    public halt() {\n        this._shouldPropagate = false;\n    }\n\n    /**\n     * Dispatch/Broadcast Signal to all listeners added to the queue.\n     * @param {...*} [paramsArr] Parameters that should be passed to each handler.\n     */\n    public dispatch(...paramsArr:any[]) {\n\n        if (!this.active) {\n            return;\n        }\n\n        var n:number = this._bindings.length;\n        var bindings:SignalBinding[];\n\n        if (this.memorize) {\n            this._prevParams = paramsArr;\n        }\n\n        if (!n) {\n            //should come after memorize\n            return;\n        }\n\n        bindings = this._bindings.slice(0); //clone array in case add/remove items during dispatch\n\n        this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.\n\n        //execute all callbacks until end of the list or until a callback returns `false` or stops propagation\n        //reverse loop since listeners with higher priority will be added at the end of the list\n        do {\n            n--;\n        } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);\n\n    }\n\n    /**\n     * Forget memorized arguments.\n     * @see Signal.memorize\n     */\n    public forget() {\n        this._prevParams = null;\n    }\n\n    /**\n     * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).\n     * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will\n     * throw errors.</p>\n     */\n    public dispose() {\n        this.removeAll();\n        this._bindings = null;\n        this._prevParams = null;\n    }\n\n    /**\n     * @return {string} String representation of the object.\n     */\n    public toString():string {\n        return '[Signal active:' + this.active + ' numListeners:' + this.getNumListeners() + ']';\n    }\n\n}","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n *\tObject that represents a binding between a Signal and a listener function. Released under the MIT license\n *\thttp://millermedeiros.github.com/js-signals/\n *\n *\t@author \tStefan Herndlbauer, 2015, Code refactoring and improvements\n *\t@author \tRichard Davey, 2013, TypeScript conversion\n *\t@author\t\tMiller Medeiros, 2012, JS Signals\n *\t@author\t\tRobert Penner, 2009, AS Signals\n *\n *  @url        http://www.gorillabyte.com\n */\n\nimport {Signal} from './Signal';\n\nexport class SignalBinding {\n    /**\n     * SignalBinding\n     * @param {Signal} signal Reference to Signal object that listener is currently bound to.\n     * @param {Function} listener Handler function bound to the signal.\n     * @param {boolean} isOnce If binding should be executed just once.\n     * @param {Object} [listenerContext] Context on which listener will be executed\n     *        (object that should represent the `this` variable inside listener function).\n     * @param {Number} [priority] The priority level of the event listener. (default = 0).\n     */\n    constructor(signal:Signal, listener, isOnce:boolean, listenerContext, priority?:number) {\n        this._listener = listener;\n        this._isOnce = isOnce;\n        this.context = listenerContext;\n        this._signal = signal;\n        this.priority = priority || 0;\n    }\n\n    /**\n     * Handler function bound to the signal.\n     * @type Function\n     * @private\n     */\n    private _listener;\n\n    /**\n     * If binding should be executed just once.\n     * @type boolean\n     * @private\n     */\n    private _isOnce:boolean;\n\n    /**\n     * Context on which listener will be executed (object that should\n     * represent the `this` variable inside listener function).\n     * @memberOf SignalBinding.prototype\n     * @name context\n     * @type Object|undefined|null\n     */\n    public context;\n\n    /**\n     * Reference to Signal object that listener is currently bound to.\n     * @type Signal\n     * @private\n     */\n    private _signal: Signal;\n\n    /**\n     * Listener priority\n     * @type Number\n     */\n    public priority: number;\n\n    /**\n     * If binding is active and should be executed.\n     * @type boolean\n     */\n    public active:boolean = true;\n\n    /**\n     * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)\n     * @type Array|null\n     */\n    public params = null;\n\n    /**\n     * Call listener passing arbitrary parameters.\n     * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue,\n     * this method is used internally for the signal dispatch.</p>\n     * @param {Array} [paramsArr] Array of parameters that should be passed to the listener\n     * @return {*} Value returned by the listener.\n     */\n    public execute(paramsArr?: any[]) {\n        var handlerReturn;\n        var params;\n\n        if (this.active && !!this._listener) {\n            params = this.params ? this.params.concat(paramsArr) : paramsArr;\n            handlerReturn = this._listener.apply(this.context, params);\n\n            if (this._isOnce) {\n                this.detach();\n            }\n        }\n        return handlerReturn;\n    }\n\n    /**\n     * Detach binding from signal.\n     * - alias to: mySignal.remove(myBinding.getListener());\n     * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.\n     */\n    public detach() {\n        return this.isBound() ? this._signal.remove(this._listener, this.context) : null;\n    }\n\n    /**\n     * @return {Boolean} `true` if binding is still bound to the signal and have a listener.\n     */\n    public isBound():boolean {\n        return (!!this._signal && !!this._listener);\n    }\n\n    /**\n     * @return {boolean} If SignalBinding will only be executed once.\n     */\n    public isOnce():boolean {\n        return this._isOnce;\n    }\n\n    /**\n     * @return {Function} Handler function bound to the signal.\n     */\n    public getListener() {\n        return this._listener;\n    }\n\n    /**\n     * @return {Signal} Signal that listener is currently bound to.\n     */\n    public getSignal() {\n        return this._signal;\n    }\n\n    /**\n     * Delete instance properties\n     * @private\n     */\n    public _destroy() {\n        this._signal = null;\n        this._listener = null;\n        this.context = null;\n    }\n\n    /**\n     * @return {string} String representation of the object.\n     */\n    public toString():string {\n        return '[SignalBinding isOnce:' + this._isOnce\n            + ', isBound:' + this.isBound()\n            + ', active:' + this.active + ']';\n    }\n}"],"sourceRoot":"/source/"}