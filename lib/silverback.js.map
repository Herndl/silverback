{"version":3,"sources":["webpack:///webpack/bootstrap e740e415be099d7337b2","webpack:///./src/index.ts","webpack:///./src/utils/Dictionary.ts","webpack:///./src/utils/LinkedList.ts","webpack:///./src/core/Engine.ts","webpack:///./src/utils/SystemSort.ts","webpack:///./src/core/ComponentsFamily.ts","webpack:///./src/core/NodePool.ts","webpack:///./~/mini-signals/lib/mini-signals.js","webpack:///./src/core/Entity.ts","webpack:///./src/core/System.ts","webpack:///./src/core/Node.ts","webpack:///./src/core/Scene.ts"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;AC/BA,8BAAmC;AACnC,8BAAmC;AAGnC,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA4B;AAC5B,8BAAgC;AAChC,8BAA6B;AAC7B,8BAAwC,I;;;;;;ACfxC;;;;;;;AAKI;;;AACQ,cAAM,QAAM;AACZ,cAAQ,UAChB;AAEU;;;;6BAAI,KAAO;AACjB,iBAAY,WAAO,KAAS,SAAM;AAE/B,iBAAS,YAAM,GAAE;AACZ,sBAAQ,QAAU,YAC1B;AAAM,oBAAE;AACA,sBAAM,MAAK,KAAM;AACjB,sBAAQ,QAAK,KACrB;AACJ;AAEa;;;gCAAI;AACb,iBAAY,WAAO,KAAS,SAAM;AAE/B,iBAAS,YAAM,GAAE;AAChB,qBAAgB,eAAO,KAAQ,QAAW;AACtC,sBAAM,MAAO,OAAS,UAAK;AAC3B,sBAAQ,QAAO,OAAS,UAAK;AAC3B,wBACV;AAAM,oBAAE;AACJ,uBACJ;AACJ;AAEe;;;kCAAI;AACf,iBAAS,QAAQ;AACjB,iBAAY,WAAO,KAAS,SAAM;AAE/B,iBAAS,YAAM,GAAE;AACX,yBAAO,KAAQ,QACxB;AAAC;AACK,oBACV;AAEe;;;kCAAQ;AACnB,iBAAO,MAAO,KAAM,MAAQ;AAC5B,iBAAQ;AAEJ,kBAAC,IAAK,IAAI,GAAG,IAAM,KAAE,EAAG,GAAG;AACxB,uBAAO,KAAM,MAAI;AACjB,qBAAI,QAAa,SAAE;AACZ,4BACV;AACJ;AAAC;AACK,oBAAC,CACX;AAEU;;;6BAAQ;AACd,iBAAO,MAAO,KAAM,MAAQ;AAC5B,iBAAQ;AAEJ,kBAAC,IAAK,IAAI,GAAG,IAAM,KAAE,EAAG,GAAG;AACxB,uBAAO,KAAM,MAAI;AACjB,qBAAI,QAAa,SAAE;AACZ,4BACV;AACJ;AAAC;AACK,oBACV;AAEa;;;;AACT,iBAAO,MAAO,KAAM,MAAQ;AAC5B,iBAAQ;AACR,iBAAU;AACV,iBAAW,UAAa;AAEpB,kBAAC,IAAK,IAAI,GAAG,IAAM,KAAE,EAAG,GAAG;AACxB,uBAAO,KAAM,MAAI;AACf,yBAAO,KAAQ,QAAI;AACjB,yBAAK,KAChB;AAAC;AACK,oBACV;AAEc;;;iCAAO;AACjB,iBAAO,MAAO,KAAM,MAAQ;AAC5B,iBAAQ;AACR,iBAAU;AAEN,kBAAC,IAAK,IAAI,GAAG,IAAM,KAAE,EAAG,GAAG;AACxB,uBAAO,KAAM,MAAI;AACf,yBAAO,KAAQ,QAAI;AACxB,qBAAa,YAAS,OAAI,KAAS;AAChC,qBAAU,cAAc,UAAE;AACnB,4BACV;AACJ;AAAC;AACK,oBACV;AACH;;;;;;AAnGY,SAAU,aAmGtB,W;;;;;;AC3FD;;;;;;;AAAA;;;AAQY,cAAK,QAAQ;AAQb,cAAK,QAAQ;AAQb,cAAO,UAiMnB;AAAC;;;;6BAxLkB;AAGX,iBAAQ;AACA,uBAAM;AACN,uBAAM;AACF,2BACV;AAJS;AAOR,iBAAK,KAAQ,YAAO,GAAE;AACjB,sBAAM,QAAQ;AACd,sBAAM,QAAQ;AAEf,qBAAC,OAAW,KAAK,SAAiB,aAAE;AAC/B,0BAAK,OAAO,KAAS,WAC7B;AACJ;AAAM,oBAAE;AAGA,sBAAM,MAAK,OAAQ;AACnB,sBAAS,WAAO,KAAO;AACvB,sBAAK,OAAQ;AACb,sBAAM,QACd;AAAC;AAEG,kBACR;AAQW;;;8BAAa;AAEjB,iBAAM,QAAG,CAAE,KAAS,QAAO,KAAS,SAAE;AACrC,qBAAW,UAAO,KAAM;qBACnB,IAAK;AAEV,wBAAU,MAAQ,OAAG;AACV,+BAAU,QACrB;AAAC;AAEK,wBAAQ,QAClB;AAAM,oBAAE;AACE,wBACV;AACJ;AASa;;;gCAAa;AAEnB,iBAAM,QAAG,CAAE,KAAS,QAAO,KAAS,SAAE;AAErC,qBAAW,UAAO,KAAO;AACzB,qBAAK,IAAK;AAGP,qBAAM,UAAO,GAAE;AACV,0BAAM,QAAU,QAAM;AASvB,yBAAC,CAAK,KAAO,OAAE;AACV,8BAAM,QACd;AAAM,4BAAE;AACA,8BAAM,MAAS,WACvB;AAGJ;AAAM,4BAAU,UAAS,KAAQ,UAAK,GAAE;AAC7B,+BAAO,KAAO;AACjB,0BAAM,QAAU,QAAU;AAC1B,0BAAM,MAAK,OACnB;AAAM,kBAJI,MAIF;AAGJ,4BAAU,MAAQ,OAAG;AACV,mCAAU,QACrB;AAAC;AAGM,6BAAS,SAAK,OAAU,QAAM;AAC9B,6BAAK,KAAS,WAAU,QACnC;AAAC;AAGG,sBAAW;AAGT,wBAAQ,QAElB;AAAM,oBAAE;AACE,wBACV;AACJ;AAOW;;;;AACD,oBAAK,KACf;AAOc;;;;AACV,iBAAU,SAAM;AAChB,iBAAW,UAAO,KAAO;AAEzB,oBAAc,SAAG;AACP,wBAAK,KAAQ,QAAO;AACnB,2BAAU,QACrB;AAAC;AACK,oBACV;AAOe;;;;AACL,oBAAK,KAAU,UACzB;AAMgB;;;6BAsBD;AACX,iBAAW,UAAW,KAAO;AAC1B,iBAAC,OAAc,QAAK,KAAG,OAAgB,YAAE;AACxC,wBAAc,SAAG;AACV,yBAAQ,QAAK,KAAG,GAAO,OAAE;AAClB,gCAAQ,QAClB;AAAC;AACM,+BAAU,QACrB;AACJ;AAAM,oBAAE;AACG,yBAAI,IAAc,gBAAO,OACpC;AAAC;AACK,oBACV;AACH;;;;AAnCU,iBAAK,KAAM,UAAU,MAAE;AAChB,wBAAK,KAAM,MACrB;AAAC;AACK,oBACV;AAMe;;;;AACR,iBAAK,KAAM,UAAU,MAAE;AAChB,wBAAK,KAAM,MACrB;AAAC;AACK,oBACV;AAMU;;;;;;AA3MD,SAAU,aAyNtB,W;;;;;;;;;;;;AC1ND,wCAA+C;AAC/C,wCAA+C;AAC/C,wCAA6C;AAE7C,8CAAoD;AAGpD,KAAgB,aAAU,oBAM1B;;;AA8BI;;;AAlBO,cAAQ,WAAiB;AAgBzB,cAAW,cAAQ;AAGlB,cAAY,cAAM;AAClB,cAAY,cAAG,IAAI,aAAa;AAChC,cAAW,aAAG,IAAI,aAAa;AAC/B,cAAa,eAAG,IAAI,aAAa;AACjC,cAAY,cAAG,IAAI,aAAa;AAChC,cAAU,YAAG,IAAI,aAAa;AAC9B,cAAe,iBAAG,IAAiB;AAEnC,cAAY,cAAG,mBACvB;AAKmB;;;;mCAuBW;AACxB,iBAAK,KAAa,aAAI,IAAO,OAAO,OAAE;AACpC,uBAAM,IAAS,MAAmB,qBAAS,OAAK,OACpD;AAAC;AACG,kBAAY,YAAI,IAAS;AACzB,kBAAa,aAAI,IAAO,OAAK,MAAU;AACrC,oBAAe,eAAI,IAAK,KAAgB,iBAAQ;AAChD,oBAAiB,iBAAI,IAAK,KAAkB,mBAAQ;AACpD,oBAAY,YAAI,IAAK,KAAmB,oBAAQ;AAElD,kBAAU,UAAQ,QAAC,UAAW,YAAgB;AACxC,wBAAU,UACpB;AACJ;AAQmB;;;sCAAe,QAAe;AACvC,oBAAe,eAAa;AAC5B,oBAAiB,iBAAa;AAC9B,oBAAY,YAAa;AAE7B,iBAAC,OAAY,UAAiB,aAAE;AAC1B,sBAAC,IAAK,IAAI,GAAG,IAAO,KAAY,YAAO,QAAK,KAAG;AAC7C,yBAAK,KAAY,YAAK,KAAG,OAAY,QAAE;AACjC,8BAAY,YAAO,OAAI;AACvB,8BAAa,aAAO,OAAO,OACnC;AACJ;AACJ;AAAM,oBAAE;AACA,sBAAY,YAAO,OAAQ;AAC3B,sBAAa,aAAO,OAAO,OACnC;AAAC;AACG,kBAAU,UAAQ,QAAC,UAAW,YAAiB;AACzC,wBAAa,aACvB;AACJ;AAQsB;;;yCAAY;AAC5B,iBAAK,KAAa,aAAI,IAAO,OAAE;AACvB,wBAAK,KAAa,aAAS,SACrC;AAAC;AACK,oBACV;AAKwB;;;;AACpB,iBAAY,WAAO,KAAY,YAAO,SAAK;AACvC,kBAAC,IAAK,IAAW,UAAG,KAAK,GAAK,KAAG;AAC7B,sBAAa,aAAK,KAAY,YAAK,KAAG,IAC9C;AACJ;AAOe;;;kCAAY;AACnB,kBAAW,WAAI,IAAQ;AACvB,kBAAY,YAAI,IAAM,MAAK,MAAS;AACnC,mBAAY,YAAI,IAAK,KAAkB,mBAEhD;AAQkB;;;qCAAY,OAAe;AACvC,iBAAC,OAAY,UAAiB,aAAE;AAC1B,sBAAC,IAAK,IAAI,GAAG,IAAO,KAAW,WAAO,QAAK,KAAG;AAC5C,yBAAK,KAAW,WAAK,KAAG,OAAW,OAAE;AAC/B,8BAAW,WAAO,OAC1B;AACJ;AACJ;AAAM,oBAAE;AACA,sBAAW,WAAO,OAC1B;AAAC;AACG,kBAAY,YAAO,OAAM,MAAO;AAC/B,mBAAY,YACrB;AAKsB;;;;AAClB,iBAAY,WAAO,KAAW,WAAO,SAAK;AACtC,kBAAC,IAAK,IAAW,UAAG,KAAK,GAAK,KAAG;AAC7B,sBAAY,YAAK,KAAW,WAAK,KAAG,IAC5C;AACJ;AAQqB;;;wCAAY;AAC3B,iBAAK,KAAY,YAAI,IAAO,OAAE;AACtB,wBAAK,KAAY,YAAS,SACpC;AAAC;AACK,oBACV;AASe;;;kCAAK;AACV,oBAAK,KAAW,WAAI,IAC9B;AAckB;;;qCAAU;AACtB,iBAAK,KAAU,UAAI,IAAY,YAAE;AACzB,wBAAK,KAAU,UAAS,SAAW,WAC7C;AAAM,oBAAE;AACJ,qBAAU,SAAW,IAAQ,KAAY,YAAU,WAAQ;AACvD,sBAAU,UAAI,IAAU,WAAU;AAClC,sBAAC,IAAK,IAAI,GAAG,IAAO,KAAY,YAAO,QAAK,KAAG;AACzC,4BAAU,UAAK,KAAY,YAAK,KAC1C;AAAC;AACK,wBAAO,OACjB;AACJ;AAYsB;;;yCAAU;AAC1B,iBAAK,KAAU,UAAI,IAAY,YAAE;AAC3B,sBAAU,UAAS,SAAW,WACtC;AAAM,oBAAE;AACJ,uBAAM,IAAS,MACnB;AAAC;AACG,kBAAU,UAAO,OACzB;AAcgB;;;mCAAc,QAAkB;AACtC,oBAAS,WAAW,WAAK;AACzB,oBAAY,YAAO;AACrB,kBAAY,YAAK,KAAS;AAC1B,kBAAY,cAAG,aAAU,QAAK,KACtC;AASgB;;;mCAAK;AACb,kBAAC,IAAK,IAAI,GAAK,MAAO,KAAY,YAAO,QAAG,IAAM,KAAK,KAAG;AACxD,qBAAK,KAAY,YAAG,GAAG,GAAO,OAAE;AACxB,4BAAK,KAAY,YAC3B;AACJ;AAAC;AACK,oBACV;AAQmB;;;sCAAc,QAAe;AAC1C,iBAAC,OAAY,UAAiB,aAAE;AAC1B,sBAAC,IAAK,IAAI,GAAK,MAAO,KAAY,YAAO,QAAG,IAAM,KAAK,KAAG;AACxD,yBAAK,KAAY,YAAG,OAAY,QAAE;AAC5B,8BAAY,YAAO,OAAE,GAC7B;AACJ;AACJ;AAAM,oBAAE;AACA,sBAAY,YAAO,OAAM,QAAI,GACrC;AAAC;AACK,oBAAiB,iBAC3B;AAKuB;;;;AACf,kBAAC,IAAK,IAAO,KAAY,YAAO,SAAI,GAAG,KAAK,GAAK,KAAG;AAChD,sBAAa,aAAK,KAAY,YAAG,IACzC;AAAC;AAEL;AAQa;;;gCAAY;AACjB,kBAAS,WAAQ;AACjB,kBAAC,IAAK,IAAI,GAAK,MAAO,KAAY,YAAO,QAAG,IAAM,KAAK,KAAG;AACtD,sBAAY,YAAG,GAAO,OAC9B;AAAC;AACG,kBAAS,WAAS;AAClB,kBAAe,eACvB;AAK0B;;;4CAAc,QAAgB;AAClD,iBAAK,KAAa,aAAI,IAAU,UAAE;AAC5B,sBAAa,aAAO,OAAU;AAC9B,sBAAa,aAAI,IAAO,OAAK,MACrC;AAAM,oBAAE;AACJ,uBAAM,IAAS,MACnB;AACJ;AAKyB;;;2CAAY,OAAgB;AAC/C,iBAAK,KAAY,YAAI,IAAU,UAAE;AAC3B,sBAAY,YAAO,OAAU;AAC7B,sBAAY,YAAI,IAAM,MAAK,MACnC;AAAM,oBAAE;AACJ,uBAAM,IAAS,MACnB;AACJ;AAKuB;;;yCAAc,QAA0B;AACvD,kBAAU,UAAQ,QAAC,UAAW,YAAgB;AACpC,wBAAuB,uBAAO,QACxC;AAER;AAKyB;;;2CAAc,QAA0B;AACzD,kBAAU,UAAQ,QAAC,UAAW,YAAgB;AACpC,wBAA2B,2BAAO,QAC5C;AAER;AACH;;;;AA/Ta,oBAAK,KAAY,YAC3B;AAKiB;;;;AACP,oBAAK,KAAW,WAC1B;AAKkB;;;;AACR,oBAAK,KACf;AAOgB;;;;;;AApEP,SAAM,SA6WlB,O;;;;;;;;ACrWD,eAAmB,OAAmB,YAAoB;AACtD,SAAQ,OAAQ,MAAa;AACxB,WAAY,cAAQ,MAAc;AAClC,WAAa,eACtB;AAAC;AAED,oBAAwB,OAAa,MAAc;AAC/C,SAAS,QAAQ,MAAK,KAAM,MAAC,CAAM,QAAQ,QAAM,IAAU;AAC3D,SAAK,IAAQ;AACb,SAAK,IAAS;AAGd,YAAQ,KAAK,GAAG;AAGZ,gBAAY,MAAG,GAAS,WAAQ,OAAG;AAEnC;AAAC;AAGD,gBAAY,MAAG,GAAS,WAAQ,OAAG;AAEnC;AAAC;AAGE,aAAE,KAAM,GAAE;AACL,kBAAM,OAAG,GAAK;AAGd;AAER;AACJ;AAAC;AAEK,YACV;AAAC;AAOD,qBAAwC,OAAO,MAAQ;AACnD,SAAU;AAGP,SAAM,MAAO,SAAK,GAAE;AAGf,gBAAG,OAAW,SAAa,WAAI,IAAQ;AACtC,iBAAG,OAAY,UAAa,WAAQ,MAAO,SAAI,IAAS;AAGxD,iBAAY,UAAM,OAAM,MAAS;AAGnC,aAAK,OAAQ,QAAK,GAAE;AACT,wBAAM,OAAM,MAAO,QACjC;AAAC;AAEE,aAAM,QAAS,OAAE;AACN,wBAAM,OAAO,OAC3B;AACJ;AAAC;AACK,YACV;AAAC;AAvBD;mBAuBC,W;;;;;;;;;;;;ACtFD,sCAAoC;AACpC,wCAA+C;AAI/C,wCAEA;;;AAeI,+BAAyB,WAAe;;;AAChC,cAAW,aAAa;AACxB,cAAQ,UAAU;AAElB,cACR;AAMa;;;;;AACL,kBAAO,SAAG,IAAI,aAAa;AAC3B,kBAAU,YAAG,IAAI,aAAa;AAC9B,kBAAY,cAAG,IAAI,aAAa;AAEpC,iBAAS,QAAO,KAAW,WAAU;AAElC,kBAAC,IAAQ,QAAU,OAAE;AACjB,qBAAM,MAAe,eAAO,OAAE;AACzB,0BAAY,YAAI,IAAK,MAAO,MACpC;AACJ;AAAC;AACG,kBAAU,YAAG,IAAI,WAAQ,SAAK,KAAW,YAAM,KAAc;AAC7D,kBAAU,UAAQ,QAAK,KAAU,UACzC;AAOmB;;;mCAQW;AACtB,kBAAW,WACnB;AAM6B;;;gDAAc,QAA0B;AAC7D,kBAAW,WACnB;AAOiC;;;oDAAc,QAA0B;AACjE,kBAAc,cACtB;AAMmB;;;sCAAc;AACzB,kBAAc,cACtB;AAMiB;;;oCAAc;AACxB,iBAAC,CAAK,KAAU,UAAI,IAAS,SAAE;AAE1B,sBAAY,YAAQ,QAAC,UAAe;AACjC,yBAAC,CAAO,OAAa,aAAiB,iBAAE;AAE3C;AACJ;AAAG;AAED,qBAAO,OAAS,SAAO,SAAK,GAAE;AAC5B,yBAAQ,OAAO,KAAU,UAAO;AAChC,yBAAS,QAAO,KAAO;AAEpB,0BAAC,IAAQ,QAAU,OAAE;AACjB,6BAAM,MAAe,eAAO,OAAE;AAE3B,iCAAC,CAAO,OAAa,aAAM,MAAM,MAAO,OAAE;AAG5C;AAAM,oCAAE;AAEA,sCAAM,QAAS,OAAa,aAAM,MAAM,MAChD;AACJ;AACJ;AAAC;AACG,0BAAO,SAAU;AAEjB,0BAAU,UAAI,IAAO,QAAQ;AAC7B,0BAAO,OAAI,IACnB;AACJ;AACJ;AAKoB;;;uCAAc;AAE5B,iBAAK,KAAU,UAAS,SAAS,SAAE;AACjC,qBAAQ,OAAO,KAAU,UAAS,SAAS;AACvC,sBAAU,UAAO,OAAS;AAE3B,sBAAC,IAAK,IAAI,GAAG,IAAO,KAAO,OAAO,QAAK,KAAG;AACvC,yBAAK,KAAO,OAAK,KAAG,OAAU,MAAE;AAC1B,8BAAO,OAAO,OACtB;AACJ;AAAC;AAEE,qBAAK,KAAQ,QAAU,UAAE;AACpB,0BAAU,UAAM,MAAO;AACvB,0BAAQ,QAAe,eAAI,IAAK,KAAsB,uBAC9D;AAAM,wBAAE;AACA,0BAAU,UAAQ,QAC1B;AACJ;AACJ;AAM6B;;;;AACrB,kBAAQ,QAAe,eAAa;AACpC,kBAAU,UAClB;AAKc;;;;AACN,kBAAC,IAAK,IAAI,GAAG,IAAO,KAAO,OAAO,QAAK,KAAG;AACtC,sBAAU,UAAO,OAAK,KAAO,OAAK,KAAG,GAAS;AAC9C,sBAAO,OAAO,OACtB;AACJ;AACH;;;;AAnHa,oBAAK,KACf;AAMgB;;;;;;AAvDP,SAAgB,mBAmK5B,iB;;;;;;ACvKD;;;;;;;AASI,uBAAqB,WAAuB;;;AACpC,cAAW,aAAa;AACxB,cAAY,cACpB;AAKU;;;;;AACJ,iBAAK,KAAO,OAAE;AACZ,qBAAQ,OAAO,KAAO;AAClB,sBAAM,QAAO,KAAM,MAAU;AAC7B,sBAAS,WAAQ;AACf,wBACV;AAAM,oBAAE;AACE,wBAAO,OAAO,OAAK,KAC7B;AACJ;AAKc;;;iCAAS;AACf,kBAAO,SAAQ;AACf,kBAAK,OAAQ;AACb,kBAAS,WAAO,KAAO;AACvB,kBAAM,QACd;AAKY;;;+BAAK;AACT,kBAAS,WAAO,KAAY;AAC5B,kBAAW,aACnB;AAKmB;;;;AACf,oBAAU,KAAW,YAAG;AACpB,qBAAQ,OAAW,KAAY;AAC3B,sBAAW,aAAO,KAAU;AAC5B,sBAAQ,QAChB;AACJ;AACH;;;;;;AAxDY,SAAQ,WAwDpB,S;;;;;;ACpED;;AAEA;AACA;AACA,EAAC;;AAED,kCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEljB,kDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,EAAC;;AAED;;AAEA;AACA;;;;;;;;;;;;;;;AC9IA,wCAA+C;AAC/C,KAAgB,aAAU,oBAE1B;;;AA6BI;aAAgB,6DAAY;;;;AACpB,cAAY,cAAG,IAAI,aAAa;AAChC,cAAe,iBAAG,IAAiB;AACnC,cAAiB,mBAAG,IAAiB;AACrC,cAAY,cAAG,IAAiB;AAElC,aAAK,KAAO,SAAK,GAAE;AACb,kBAAM,QACd;AAAM,gBAAE;AACA,kBAAM,QAAc,WAAC,EAAQ,OACrC;AACJ;AAMe;;;;sCA0BkB,WAAiB;AAC5C,iBAAC,OAAqB,mBAAiB,aAAE;AACzB,kCAAY,UAAY,YAC1C;AAAC;AACC,iBAAK,KAAY,YAAI,IAAiB,iBAAE;AAClC,sBAAgB,gBACxB;AAAC;AACG,kBAAY,YAAI,IAAe,gBAAa;AAC5C,kBAAe,eAAS,SAAK,MAAkB;AAC7C,oBACV;AAQsB;;;yCAAe;AACjC,iBAAa,YAAW,KAAY,YAAS,SAAiB;AAC3D,iBAAW,WAAE;AACR,sBAAY,YAAO,OAAiB;AACpC,sBAAiB,iBAAS,SAAK,MAAkB;AAC/C,wBACV;AAAC;AACK,oBACV;AAQmB;;;sCAAsB;AAC/B,oBAAK,KAAY,YAAS,SACpC;AAQmB;;;sCAAsB;AAC/B,oBAAK,KAAY,YAAI,IAC/B;AAOa;;;;AACT,iBAAkB,iBAAM;AAEpB,kBAAY,YAAQ,QACpB,UAAe,gBAAW;AACR,gCAAK,KACvB;AACF;AACI,oBACV;AAEgB;;;;AAKZ,iBAAQ,OAAM;AACR,yBAAe,UAAK,MAAE,UAAY,KAAK;AACtC,qBAAC,QAAU,sDAAc,UAAE;AACvB,yBAAK,KAAQ,QAAK,QAAM,GAAE;AAE7B;AAAC;AACG,0BAAK,KACb;AAAC;AACK,wBACV;AAAC,cARU,EASf;AACH;;;;AAzGa,oBAAK,KACf;AACe;2BAAa;AACtB,iBAAK,KAAM,UAAW,OAAE;AACtB,qBAAY,WAAc,KAAO;AAC7B,sBAAM,QAAS;AACf,sBAAY,YAAS,SAAK,MAClC;AACJ;AAiBmB;;;2BAgES;AACpB,kBAAc,gBACtB;AAEe;;;;;;AA1IA,QAAS,YAAK;AAFpB,SAAM,SAwJlB,O;;;;;;ACnKD;;;;;;;AAAA;;;AAKW,cAAQ,WAAe;AAKvB,cAAI,OAAe;AAMnB,cAAQ,WAuCnB;AAAC;;;;qCA/BgC;AACzB,mBAAM,IAAS,MACnB;AAQuB;;;0CAAW;AAC9B,mBAAM,IAAS,MACnB;AAYa;;;gCAAY;AACrB,mBAAM,IAAS,MACnB;AAES;;;4BAAK;AACJ,oBAAK,KAAU,UAAc,cACvC;AACH;;;;;;AAvDqB,SAAM,SAuD3B;AAEK,QAAU,UAAS,WAAQ;AAC3B,QAAU,UAAK,OAAQ;AACvB,QAAU,UAAS,WAAK,E;;;;;;AC7D9B;;;;YAAA;;;AAIW,UAAM,SAAY;AAKlB,UAAQ,WAAY;AAKpB,UAAI,OACf;AAAC;;AAfY,SAAI,OAehB,K;;;;;;;;;;;;ACzBD,wCAA+C;AAC/C,wCAA+C;AAE/C,KAAgB,aAAU,oBAE1B;;;AA+BI;aAAgB,6DAAY;;;;AACpB,cAAU,YAAG,IAAI,aAAa;AAC9B,cAAY,cAAG,IAAiB;AAChC,cAAc,gBAAG,IAAiB;AAClC,cAAY,cAAG,IAAI,aAAa;AAChC,cAAa,eAAG,IAAI,aAAa;AACjC,cAAY,cAAG,IAAiB;AAEjC,aAAM,MAAE;AACH,kBAAM,QACd;AAAM,gBAAE;AACA,kBAAM,QAAc,WAAC,EAAO,MACpC;AACJ;AAMe;;;;mCAuBY,QAAc;AAClC,iBAAC,OAAkB,gBAAiB,aAAE;AAC1B,+BAAS,OACxB;AAAC;AACG,kBAAY,YAAI,IAAS;AACzB,kBAAa,aAAI,IAAO,OAAK,MAAU;AACvC,kBAAY,YAAS,SAAK,MAAe;AACvC,oBAAM,QAAQ;AACd,oBACV;AAQmB;;;sCAAc,QAAe;AAC1C,iBAAC,OAAY,UAAiB,aAAE;AAC1B,sBAAC,IAAK,IAAI,GAAG,IAAO,KAAY,YAAO,QAAK,KAAG;AAC7C,yBAAK,KAAY,YAAK,KAAG,OAAY,QAAE;AACjC,8BAAY,YAAO,OAC3B;AACJ;AACJ;AAAM,oBAAE;AACA,sBAAY,YAAO,OAC3B;AACJ;AAQwB;;;2CAAe;AAC/B,kBAAC,IAAK,IAAI,GAAG,IAAO,KAAY,YAAO,QAAK,KAAG;AAC5C,qBAAK,KAAY,YAAK,KAAG,GAAK,SAAgB,YAAE;AACzC,4BAAK,KAAY,YAAK,KAChC;AACJ;AAAC;AACK,oBACV;AAOqB;;;;AACX,oBAAK,KAAY,YAC3B;AAQwB;;;2CAAe;AAC/B,kBAAC,IAAK,IAAI,GAAK,MAAO,KAAY,YAAO,QAAG,IAAM,KAAK,KAAG;AACxD,qBAAK,KAAY,YAAK,KAAG,GAAK,SAAgB,YAAE;AACxC,4BACV;AACJ;AAAC;AACK,oBACV;AAOS;;;4BAAK;AACJ,oBAAK,KAAU,UAAc,cACvC;AACH;;;;AAlGa,oBAAK,KACf;AACe;2BAAa;AACtB,iBAAK,KAAM,UAAW,OAAE;AACtB,qBAAY,WAAc,KAAO;AAC7B,sBAAM,QAAS;AACf,sBAAY,YAAS,SAAK,MAClC;AACJ;AAcgB;;;;;;AAvED,OAAS,YAAK;AAFpB,SAAK,QAqJjB,M","file":"silverback.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./lib/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e740e415be099d7337b2\n **/","/**\n * @author       Stefan Herndlbauer <sherndlbauer@gorillabyte.com>\n * @copyright    2015-2016 Stefan Herndlbauer\n * @license      {@link https://github.com/Herndl/silverback.git/blob/master/README.md|MIT License}\n **/\n\n// Utility libraries\nexport * from './utils/Dictionary';\nexport * from './utils/LinkedList';\n\n// Core components of the engine\nexport * from './core/Engine';\nexport * from './core/Entity';\nexport * from './core/System';\nexport * from './core/Node';\nexport * from './core/NodePool';\nexport * from './core/Scene';\nexport * from './core/ComponentsFamily';\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.ts\n **/","/// <reference path=\"../../typings/index.d.ts\" />\n\nexport class Dictionary {\n\n    private _keys: any[];\n    private _values: any[];\n\n    constructor() {\n        this._keys = [];\n        this._values = [];\n    }\n\n    public add(key, value) {\n        let keyIndex = this.getIndex(key);\n\n        if (keyIndex >= 0) {\n            this._values[keyIndex] = value;\n        } else {\n            this._keys.push(key);\n            this._values.push(value);\n        }\n    }\n\n    public remove(key):any {\n        let keyIndex = this.getIndex(key);\n\n        if (keyIndex >= 0) {\n            var removedValue = this._values[keyIndex];\n            this._keys.splice(keyIndex, 1);\n            this._values.splice(keyIndex, 1);\n            return removedValue;\n        } else {\n            throw 'Key does not exist';\n        }\n    }\n\n    public getValue(key) {\n        let value = null;\n        let keyIndex = this.getIndex(key);\n\n        if (keyIndex >= 0) {\n            value = this._values[keyIndex];\n        }\n        return value;\n    }\n\n    public getIndex(testKey) {\n        let len = this._keys.length;\n        let key;\n\n        for (let i = 0; i < len; ++i) {\n            key = this._keys[i];\n            if (key === testKey) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public has(testKey) {\n        let len = this._keys.length;\n        let key;\n\n        for (let i = 0; i < len; ++i) {\n            key = this._keys[i];\n            if (key === testKey) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public values(): any[] {\n        let len = this._keys.length;\n        let key;\n        let value;\n        let arValue: any[] = [];\n\n        for (let i = 0; i < len; ++i) {\n            key = this._keys[i];\n            value = this._values[i];\n            arValue.push(value);\n        }\n        return arValue;\n    }\n\n    public forEach(action) {\n        let len = this._keys.length;\n        let key;\n        let value;\n\n        for (let i = 0; i < len; ++i) {\n            key = this._keys[i];\n            value = this._values[i];\n            var breakHere = action(key, value);\n            if (breakHere === 'return') {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/Dictionary.ts\n **/","/**\n *  Linked List implementation in JavaScript, Released under the MIT license\n *  https://github.com/nzakas/computer-science-in-javascript/\n *\n *  @author     Stefan Herndlbauer, 2015, TypeScript conversion\n *  @author     Nicholas C. Zakas, 2009, Doubly Linked List\n *\n *  @url        http://www.gorillabyte.com\n */\n\nexport class LinkedList {\n\n    /**\n     * Pointer to first item in the list.\n     * @property _head\n     * @type Object\n     * @private\n     */\n    private _head = null;\n\n    /**\n     * Pointer to last item in the list.\n     * @property _tail\n     * @type Object\n     * @private\n     */\n    private _tail = null;\n\n    /**\n     * The number of items in the list.\n     * @property _length\n     * @type number\n     * @private\n     */\n    private _length = 0;\n\n    /**\n     * Appends some data to the end of the list. This method traverses\n     * the existing list and places the value at the end in a new item.\n     * @param {any} data The data to add to the list.\n     * @return {Void}\n     * @method add\n     */\n    public add(data) {\n\n        // Create a new item object, place data in\n        var node = {\n            data: data,\n            next: null,\n            previous: null\n        };\n\n        // Special case: no items in the list yet\n        if (this._length === 0) {\n            this._head = node;\n            this._tail = node;\n            // If node has next and previous properties\n            if (typeof data.next !== 'undefined') {\n                data.next = data.previous = null;\n            }\n        } else {\n\n            // Attach to the tail node\n            this._tail.next = node;\n            node.previous = this._tail;\n            node.next = null;\n            this._tail = node;\n        }\n        // Don't forget to update the count\n        this._length++;\n    }\n\n    /**\n     * Retrieves the data in the given position in the list.\n     * @param {number} index The zero-based index of the item whose value should be returned.\n     * @return {any} The value in the \"data\" portion of the given item or null if the item doesn't exist.\n     * @method item\n     */\n    public item(index:number) {\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length) {\n            var current = this._head,\n                i = 0;\n\n            while (i++ < index) {\n                current = current.next;\n            }\n\n            return current.data;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Removes the item from the given location in the list.\n     * @param {int} index The zero-based index of the item to remove.\n     * @return {any} The data in the given position in the list or null if\n     *      the item doesn't exist.\n     * @method remove\n     */\n    public remove(index:number) {\n        // Check for out-of-bounds values\n        if (index > -1 && index < this._length) {\n\n            let current = this._head;\n            let i = 0;\n\n            // Special case: removing first item\n            if (index === 0) {\n                this._head = current.next;\n\n                /*\n                 * If there's only one item in the list and you remove it,\n                 * then this._head will be null. In that case, you should\n                 * also set this._tail to be null to effectively destroy\n                 * the list. Otherwise, set the previous pointer on the new\n                 * this._head to be null.\n                 */\n                if (!this._head) {\n                    this._tail = null;\n                } else {\n                    this._head.previous = null;\n                }\n\n                //special case: removing last item\n            } else if (index === this._length - 1) {\n                current = this._tail;\n                this._tail = current.previous;\n                this._tail.next = null;\n            } else {\n\n                //find the right location\n                while (i++ < index) {\n                    current = current.next;\n                }\n\n                //skip over the item to remove\n                current.previous.next = current.next;\n                current.next.previous = current.previous;\n            }\n\n            // Decrement the length\n            this._length--;\n\n            // Return the value\n            return current.data;\n\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the number of items in the list.\n     * @return {int} The number of items in the list.\n     * @method size\n     */\n    public size() {\n        return this._length;\n    }\n\n    /**\n     * Converts the list into an array.\n     * @return {Array} An array containing all of the data in the list.\n     * @method toArray\n     */\n    public toArray() {\n        let result = [];\n        let current = this._head;\n\n        while (current) {\n            result.push(current.data);\n            current = current.next;\n        }\n        return result;\n    }\n\n    /**\n     * Converts the list into a string representation.\n     * @return {String} A string representation of the list.\n     * @method toString\n     */\n    public toString() {\n        return this.toArray().toString();\n    }\n\n    /**\n     * Returns the first element in this list.\n     * @return {any} The first element of the list or undefined if the list is empty.\n     */\n    public get first() {\n        if (this._head !== null) {\n            return this._head.data;\n        }\n        return undefined;\n    }\n\n    /**\n     * Returns the last element in this list.\n     * @return {any} the last element in the list or undefined if the list is empty.\n     */\n    public get last() {\n        if (this._tail !== null) {\n            return this._tail.data;\n        }\n        return undefined;\n    }\n\n    /**\n     * Returns the a list element by its type.\n     * @return {any} The element of the list or null if the item was not in the list.\n     */\n    public get(type) {\n        let current:any = this._head;\n        if (typeof current.data.is === 'function') {\n            while (current) {\n                if (current.data.is(type)) {\n                    return current.data;\n                }\n                current = current.next;\n            }\n        } else {\n            console.log('This type <' + type + '> does not support this method.');\n        }\n        return null;\n    }\n}\n\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/LinkedList.ts\n **/","/**\n * @module Silverback\n * @class Engine\n */\n\n/// <reference path=\"../../typings/index.d.ts\" />\n\nimport {Entity} from './Entity';\nimport {Scene} from './Scene';\nimport {Dictionary} from '../utils/Dictionary';\nimport {LinkedList} from '../utils/LinkedList';\nimport systemSort from '../utils/SystemSort';\nimport {System} from './System';\nimport {ComponentsFamily} from './ComponentsFamily';\nimport {IFamily} from './IFamily';\n\nconst MiniSignal = require('mini-signals');\n\n/**\n * The Engine class is the central point for creating and managing your game state. Add\n * entities and systems to the engine, and fetch families of nodes from the engine.\n */\nexport class Engine {\n\n    private _systemList:Array<System>;\n    private _entityList:LinkedList;\n    private _sceneList:LinkedList;\n    private _entityNames:Dictionary;\n    private _sceneNames:Dictionary;\n    private _families:Dictionary;\n\n    /**\n     * Indicates if the engine is currently in its update loop.\n     */\n    public updating:boolean = false;\n\n    /**\n     * Dispatched when the update loop ends. If you want to add and remove systems from the\n     * engine it is usually best not to do so during the update loop. To avoid this you can\n     * listen for this signal and make the change when the signal is dispatched.\n     */\n    public updateComplete:MiniSignal;\n\n    /**\n     * The class used to manage node lists. In most cases the default class is sufficient\n     * but it is exposed here so advanced developers can choose to create and use a\n     * different implementation.\n     *\n     * The class must implement the Family interface.\n     */\n    public familyClass = null;\n\n    constructor() {\n        this._systemList = [];\n        this._entityList = new LinkedList();\n        this._sceneList = new LinkedList();\n        this._entityNames = new Dictionary();\n        this._sceneNames = new Dictionary();\n        this._families = new Dictionary();\n        this.updateComplete = new MiniSignal();\n\n        this.familyClass = ComponentsFamily;\n    }\n\n    /**\n     * Returns an array containing all the entities in the engine.\n     */\n    public get entities():Array<Entity> {\n        return this._entityList.toArray();\n    }\n\n    /**\n     * Returns an array containing all the scenes in the engine.\n     */\n    public get scenes():Array<Scene> {\n        return this._sceneList.toArray();\n    }\n\n    /**\n     * Returns an array containing all the systems in the engine.\n     */\n    public get systems():Array<System> {\n        return this._systemList;\n    }\n\n    /**\n     * Add an entity to the engine.\n     *\n     * @param entity The entity to add.\n     */\n    public addEntity(entity:Entity):void {\n        if(this._entityNames.has(entity.name)) {\n            throw new Error('The entity name ' + entity.name + ' is already in use by another entity.');\n        }\n        this._entityList.add(entity);\n        this._entityNames.add(entity.name, entity);\n        entity.componentAdded.add(this._componentAdded, this);\n        entity.componentRemoved.add(this._componentRemoved, this);\n        entity.nameChanged.add(this._entityNameChanged, this);\n\n        this._families.forEach((nodeObject, family:IFamily) => {\n            family.newEntity(entity);\n        });\n    }\n\n    /**\n     * Remove an entity from the engine.\n     *\n     * @param entity The entity to remove.\n     * @param index The index of the entity list.\n     */\n    public removeEntity(entity: Entity, index?:number):void {\n        entity.componentAdded.detachAll();\n        entity.componentRemoved.detachAll();\n        entity.nameChanged.detachAll();\n\n        if(typeof index === 'undefined') {\n            for (let i = 0; i < this._entityList.size(); i++) {\n                if(this._entityList.item(i) === entity) {\n                    this._entityList.remove(i);\n                    this._entityNames.remove(entity.name);\n                }\n            }\n        } else {\n            this._entityList.remove(index);\n            this._entityNames.remove(entity.name);\n        }\n        this._families.forEach((nodeObject, family: IFamily) => {\n            family.removeEntity(entity);\n        });\n    }\n\n    /**\n     * Get an entity based on its name.\n     *\n     * @param name The name of the entity\n     * @return The entity, or null if no entity with that name exists on the engine\n     */\n    public getEntityByName(name:string):Entity {\n        if(this._entityNames.has(name)) {\n            return this._entityNames.getValue(name);\n        }\n        return null;\n    }\n\n    /**\n     * Remove all entities from the engine.\n     */\n    public removeAllEntities():void {\n        let listSize = this._entityList.size() - 1;\n        for (let i = listSize; i >= 0; i--) {\n            this.removeEntity(this._entityList.item(i), i);\n        }\n    }\n\n    /**\n     * Add an scene to the engine.\n     *\n     * @param scene The scene to add.\n     */\n    public addScene(scene:Scene):void {\n        this._sceneList.add(scene);\n        this._sceneNames.add(scene.name, scene);\n        scene.nameChanged.add(this._sceneNameChanged, this);\n\n    }\n\n    /**\n     * Remove an scene from the engine.\n     *\n     * @param scene The scene to remove.\n     * @param index The scene index in the sceneList\n     */\n    public removeScene(scene:Scene, index?:number):void {\n        if(typeof index === 'undefined') {\n            for (let i = 0; i < this._sceneList.size(); i++) {\n                if(this._sceneList.item(i) === scene) {\n                    this._sceneList.remove(i);\n                }\n            }\n        } else {\n            this._sceneList.remove(index);\n        }\n        this._sceneNames.remove(scene.name);\n        scene.nameChanged.detachAll();\n    }\n\n    /**\n     * Remove all scenes from the engine.\n     */\n    public removeAllScenes():void {\n        let listSize = this._sceneList.size() - 1;\n        for (let i = listSize; i >= 0; i--) {\n            this.removeScene(this._sceneList.item(i), i);\n        }\n    }\n\n    /**\n     * Get an scene based on its name.\n     *\n     * @param name The name of the scene\n     * @return The scene, or null if no scene with that name exists on the engine\n     */\n    public getSceneByName(name:string):Scene {\n        if(this._sceneNames.has(name)) {\n            return this._sceneNames.getValue(name);\n        }\n        return null;\n    }\n\n    /**\n     * Get the scene instance of a particular type from within the engine.\n     *\n     * @param type The type of scene\n     * @return The instance of the scene type that is in the engine, or\n     * null if no scene of this type are in the engine.\n     */\n    public getScene(type):Scene {\n        return this._sceneList.get(type);\n    }\n\n    /**\n     * Get a collection of nodes from the engine, based on the type of the node required.\n     *\n     * <p>The engine will create the appropriate NodeList if it doesn't already exist and\n     * will keep its contents up to date as entities are added to and removed from the\n     * engine.</p>\n     *\n     * <p>If a NodeList is no longer required, release it with the releaseNodeList method.</p>\n     *\n     * @param nodeClass The type of node required.\n     * @return A linked list of all nodes of this type from all entities in the engine.\n     */\n    public getNodeList(nodeClass):LinkedList {\n        if(this._families.has(nodeClass)) {\n            return this._families.getValue(nodeClass).nodeList;\n        } else {\n            let family:IFamily = new this.familyClass(nodeClass, this);\n            this._families.add(nodeClass, family);\n            for (let i = 0; i < this._entityList.size(); i++) {\n                family.newEntity(this._entityList.item(i));\n            }\n            return family.nodeList;\n        }\n    }\n\n    /**\n     * If a NodeList is no longer required, this method will stop the engine updating\n     * the list and will release all references to the list within the framework\n     * classes, enabling it to be garbage collected.\n     *\n     * <p>It is not essential to release a list, but releasing it will free\n     * up memory and processor resources.</p>\n     *\n     * @param nodeClass The type of the node class if the list to be released.\n     */\n    public releaseNodeList(nodeClass) {\n        if(this._families.has(nodeClass)) {\n            this._families.getValue(nodeClass).cleanUp();\n        } else {\n            throw new Error('The given nodeClass was not found and can not be released.');\n        }\n        this._families.remove(nodeClass);\n    }\n\n    /**\n     * Add a system to the engine, and set its priority for the order in which the\n     * systems are updated by the engine update loop.\n     *\n     * <p>The priority dictates the order in which the systems are updated by the engine update\n     * loop. Lower numbers for priority are updated first. i.e. a priority of 1 is\n     * updated before a priority of 2.</p>\n     *\n     * @param system The system to add to the engine.\n     * @param priority The priority for updating the systems during the engine loop. A\n     * lower number means the system is updated sooner.\n     */\n    public addSystem(system:System, priority?:number) {\n        system.priority = priority | 0;\n        system.addToEngine(this);\n        this._systemList.push(system);\n        this._systemList = systemSort(this._systemList);\n    }\n\n    /**\n     * Get the system instance of a particular type from within the engine.\n     *\n     * @param type The type of system\n     * @return The instance of the system type that is in the engine, or\n     * null if no systems of this type are in the engine.\n     */\n    public getSystem(type):System {\n        for (let i = 0, len = this._systemList.length; i < len; i++) {\n            if(this._systemList[i].is(type)) {\n                return this._systemList[i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove a system from the engine.\n     *\n     * @param system The system to remove from the engine.\n     * @param index The system index in the system list.\n     */\n    public removeSystem(system:System, index?:number) {\n        if(typeof index === 'undefined') {\n            for (let i = 0, len = this._systemList.length; i < len; i++) {\n                if(this._systemList[i] === system) {\n                    this._systemList.splice(i, 1);\n                }\n            }\n        } else {\n            this._systemList.splice(index - 1, 1);\n        }\n        system.removeFromEngine(this);\n    }\n\n    /**\n     * Remove all systems from the engine.\n     */\n    public removeAllSystems():void {\n        for (let i = this._systemList.length - 1; i >= 0; i--) {\n            this.removeSystem(this._systemList[i], i);\n        }\n        return;\n    }\n\n    /**\n     * Update the engine. This causes the engine update loop to run, calling update on all the\n     * systems in the engine.\n     *\n     * @time The duration, in seconds, of this update step.\n     */\n    public update(time:number):void {\n        this.updating = true;\n        for (let i = 0, len = this._systemList.length; i < len; i++) {\n            this._systemList[i].update(time);\n        }\n        this.updating = false;\n        this.updateComplete.dispatch();\n    }\n\n    /**\n     * @private\n     */\n    private _entityNameChanged(entity:Entity, oldName:string):void {\n        if(this._entityNames.has(oldName)) {\n            this._entityNames.remove(oldName);\n            this._entityNames.add(entity.name, entity);\n        } else {\n            throw new Error('The given name was not found in the entity list.');\n        }\n    }\n\n    /**\n     * @private\n     */\n    private _sceneNameChanged(scene:Scene, oldName:string):void {\n        if(this._sceneNames.has(oldName)) {\n            this._sceneNames.remove(oldName);\n            this._sceneNames.add(scene.name, scene);\n        } else {\n            throw new Error('The given name was not found in the scene list.');\n        }\n    }\n\n    /**\n     * @private\n     */\n    private _componentAdded(entity:Entity, componentClass:() => any):void {\n        this._families.forEach((nodeObject, family:IFamily) => {\n                family.componentAddedToEntity(entity, componentClass);\n            }\n        );\n    }\n\n    /**\n     * @private\n     */\n    private _componentRemoved(entity:Entity, componentClass:() => any):void {\n        this._families.forEach((nodeObject, family:IFamily) => {\n                family.componentRemovedFromEntity(entity, componentClass);\n            }\n        );\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Engine.ts\n **/","/*\n * Insertion sort implementation in JavaScript\n * Copyright (c) 2012 Nicholas C. Zakas\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of items software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and items permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Swaps two values in an array.\n * @param {Array} items The array containing the items.\n * @param {int} firstIndex Index of first item to swap.\n * @param {int} secondIndex Index of second item to swap.\n * @return {void}\n */\nfunction swap(items, firstIndex:number, secondIndex:number):void {\n    let temp = items[firstIndex];\n    items[firstIndex] = items[secondIndex];\n    items[secondIndex] = temp;\n}\n\nfunction partition(items, left:number, right:number) {\n    let pivot = items[Math.floor((right + left) / 2)].priority;  // pivot value is middle item\n    let i = left;     // starts from left and goes right to pivot index\n    let j = right;    // starts from right and goes left to pivot index\n\n    // while the two indices don't match\n    while (i <= j) {\n\n        // if the item on the left is less than the pivot, continue right\n        while (items[i].priority < pivot) {\n            i++;\n        }\n\n        // if the item on the right is greater than the pivot, continue left\n        while (items[j].priority > pivot) {\n            j--;\n        }\n\n        // if the two indices still don't match, swap the values\n        if (i <= j) {\n            swap(items, i, j);\n\n            // change indices to continue loop\n            i++;\n            j--;\n        }\n    }\n    // this value is necessary for recursion\n    return i;\n}\n\n/**\n * A quicksort implementation in JavaScript. The array is sorted in place.\n * @param {Array} items An array of items to sort.\n * @return {Array} The sorted array.\n */\nexport default function systemSort(items, left?, right?) {\n    let index;\n\n    // performance - don't sort an array with zero or one items\n    if (items.length > 1) {\n\n        // fix left and right values - might not be provided\n        left = typeof left !== 'number' ? 0 : left;\n        right = typeof right !== 'number' ? items.length - 1 : right;\n\n        // split up the entire array\n        index = partition(items, left, right);\n\n        // if the returned index\n        if (left < index - 1) {\n            systemSort(items, left, index - 1);\n        }\n\n        if (index < right) {\n            systemSort(items, index, right);\n        }\n    }\n    return items;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/SystemSort.ts\n **/","/// <reference path=\"../../typings/index.d.ts\" />\n\n/**\n * The default class for managing a NodeList. This class creates the NodeList and adds and removes\n * nodes to/from the list as the entities and the components in the engine change.\n *\n * It uses the basic entity matching pattern of an entity system - entities are added to the list if\n * they contain components matching all the public properties of the node class.\n */\nimport {NodePool} from './NodePool';\nimport {LinkedList} from '../utils/LinkedList';\nimport {Engine} from './Engine';\nimport {Entity} from './Entity';\nimport {IFamily} from './IFamily';\nimport {Dictionary} from '../utils/Dictionary';\n\nexport class ComponentsFamily implements IFamily {\n    private _nodes:LinkedList;\n    private _entities:Dictionary;\n    private _nodeClass;\n    private _components:Dictionary;\n    private _nodePool:NodePool;\n    private _engine:Engine;\n\n    /**\n     * The constructor. Creates a ComponentsFamily to provide a NodeList for the\n     * given node class.\n     *\n     * @param nodeClass The type of node to create and manage a NodeList for.\n     * @param engine The engine that this family is managing teh NodeList for.\n     */\n    constructor(nodeClass:any, engine:Engine) {\n        this._nodeClass = nodeClass;\n        this._engine = engine;\n\n        this._init();\n    }\n\n    /**\n     * Initialises the class. Creates the nodelist and other tools. Analyses the node to determine\n     * what component types the node requires.\n     */\n    private _init() {\n        this._nodes = new LinkedList();\n        this._entities = new Dictionary();   // <Entity, Node>\n        this._components = new Dictionary(); // <Type, string>\n\n        let types = this._nodeClass['types'];\n\n        for(let prop in types) {\n            if (types.hasOwnProperty(prop)) {\n                this._components.add(prop, types[prop]);\n            }\n        }\n        this._nodePool = new NodePool(this._nodeClass, this._components);\n        this._nodePool.dispose(this._nodePool.get());\n    }\n\n    /**\n     * The nodelist managed by this family. This is a reference that remains valid always\n     * since it is retained and reused by Systems that use the list. i.e. we never recreate the list,\n     * we always modify it in place.\n     */\n    public get nodeList():LinkedList {\n        return this._nodes;\n    }\n\n    /**\n     * Called by the engine when an entity has been added to it. We check if the entity should be in\n     * this family's NodeList and add it if appropriate.\n     */\n    public newEntity(entity:Entity) {\n        this.addIfMatch(entity);\n    }\n\n    /**\n     * Called by the engine when a component has been added to an entity. We check if the entity is not in\n     * this family's NodeList and should be, and add it if appropriate.\n     */\n    public componentAddedToEntity(entity:Entity, componentClass:() => any) {\n        this.addIfMatch(entity);\n    }\n\n    /**\n     * Called by the engine when a component has been removed from an entity. We check if the removed component\n     * is required by this family's NodeList and if so, we check if the entity is in this this NodeList and\n     * remove it if so.\n     */\n    public componentRemovedFromEntity(entity:Entity, componentClass:() => any) {\n        this.removeIfMatch(entity);\n    }\n\n    /**\n     * Called by the engine when an entity has been rmoved from it. We check if the entity is in\n     * this family's NodeList and remove it if so.\n     */\n    public removeEntity(entity:Entity) {\n        this.removeIfMatch(entity);\n    }\n\n    /**\n     * If the entity is not in this family's NodeList, tests the components of the entity to see\n     * if it should be in this NodeList and adds it if so.\n     */\n    public addIfMatch(entity:Entity) {\n        if (!this._entities.has(entity)) {\n\n            this._components.forEach((componentClass) => {\n                if (!entity.hasComponent(componentClass)) {\n                    return;\n                }\n            });\n            // If the entity has not components, don't add it.\n            if(entity.getAll().length > 0) {\n                let node = this._nodePool.get();\n                let types = node.types;\n\n                for(let prop in types) {\n                    if (types.hasOwnProperty(prop)) {\n\n                        if(!entity.hasComponent(types[prop].name)) {\n                            // Node prop was not found in the entity\n                            return;\n                        } else {\n                            // Add entity value to node\n                            node[prop] = entity.getComponent(types[prop].name);\n                        }\n                    }\n                }\n                node.entity = entity;\n\n                this._entities.add(entity, node);\n                this._nodes.add(node);\n            }\n        }\n    }\n\n    /**\n     * Removes the entity if it is in this family's NodeList.\n     */\n    public removeIfMatch(entity:Entity) {\n\n        if(this._entities.getValue(entity)) {\n            var node = this._entities.getValue(entity);\n            this._entities.remove(entity);\n\n            for(let i = 0; i < this._nodes.size(); i++) {\n                if(this._nodes.item(i) === node) {\n                    this._nodes.remove(i);\n                }\n            }\n\n            if (this._engine.updating) {\n                this._nodePool.cache(node);\n                this._engine.updateComplete.add(this._releaseNodePoolCache, this);\n            } else {\n                this._nodePool.dispose(node);\n            }\n        }\n    }\n\n    /**\n     * Releases the nodes that were added to the node pool during this engine update, so they can\n     * be reused.\n     */\n    private _releaseNodePoolCache() {\n        this._engine.updateComplete.detachAll();\n        this._nodePool.releaseCache();\n    }\n\n    /**\n     * Removes all nodes from the NodeList.\n     */\n    public cleanUp() {\n        for (let i = 0; i < this._nodes.size(); i++) {\n            this._entities.remove(this._nodes.item(i).entity);\n            this._nodes.remove(i);\n        }\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/ComponentsFamily.ts\n **/","/// <reference path=\"../../typings/index.d.ts\" />\n\n/**\n * This export class maintains a pool of deleted nodes for reuse by the framework. This reduces the overhead\n * from object creation and garbage collection.\n *\n * Because nodes may be deleted from a NodeList while in use, by deleting Nodes from a NodeList\n * while iterating through the NodeList, the pool also maintains a cache of nodes that are added to the pool\n * but should not be reused yet. They are then released into the pool by calling the releaseCache method.\n */\nimport {Dictionary} from '../utils/Dictionary';\n\nexport class NodePool {\n    private _tail:any;\n    private _nodeClass;\n    private _cacheTail:any;\n    private _components:Dictionary;\n\n    /**\n     * Creates a pool for the given node class.\n     */\n    constructor(nodeClass, components:Dictionary) {\n        this._nodeClass = nodeClass;\n        this._components = components;\n    }\n\n    /**\n     * Fetches a node from the pool.\n     */\n    public get() {\n        if(this._tail) {\n            var node = this._tail;\n            this._tail = this._tail.previous;\n            node.previous = null;\n            return node;\n        } else {\n            return Object.create(this._nodeClass);\n        }\n    }\n\n    /**\n     * Adds a node to the pool.\n     */\n    public dispose(node:any):void {\n        node.entity = null;\n        node.next = null;\n        node.previous = this._tail;\n        this._tail = node;\n    }\n\n    /**\n     * Adds a node to the cache\n     */\n    public cache(node):void {\n        node.previous = this._cacheTail;\n        this._cacheTail = node;\n    }\n\n    /**\n     * Releases all nodes from the cache into the pool\n     */\n    public releaseCache():void {\n        while(this._cacheTail) {\n            var node:any = this._cacheTail;\n            this._cacheTail = node.previous;\n            this.dispose(node);\n        }\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/NodePool.ts\n **/","'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar MiniSignalBinding = (function () {\n  function MiniSignalBinding(fn, once, thisArg) {\n    if (once === undefined) once = false;\n\n    _classCallCheck(this, MiniSignalBinding);\n\n    this._fn = fn;\n    this._once = once;\n    this._thisArg = thisArg;\n    this._next = this._prev = this._owner = null;\n  }\n\n  _createClass(MiniSignalBinding, [{\n    key: 'detach',\n    value: function detach() {\n      if (this._owner === null) return false;\n      this._owner.detach(this);\n      return true;\n    }\n  }]);\n\n  return MiniSignalBinding;\n})();\n\nfunction _addMiniSignalBinding(self, node) {\n  if (!self._head) {\n    self._head = node;\n    self._tail = node;\n  } else {\n    self._tail._next = node;\n    node._prev = self._tail;\n    self._tail = node;\n  }\n\n  node._owner = self;\n\n  return node;\n}\n\nvar MiniSignal = (function () {\n  function MiniSignal() {\n    _classCallCheck(this, MiniSignal);\n\n    this._head = this._tail = undefined;\n  }\n\n  _createClass(MiniSignal, [{\n    key: 'handlers',\n    value: function handlers() {\n      var exists = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\n      var node = this._head;\n\n      if (exists) return !!node;\n\n      var ee = [];\n\n      while (node) {\n        ee.push(node);\n        node = node._next;\n      }\n\n      return ee;\n    }\n  }, {\n    key: 'has',\n    value: function has(node) {\n      if (!(node instanceof MiniSignalBinding)) {\n        throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.');\n      }\n\n      return node._owner === this;\n    }\n  }, {\n    key: 'dispatch',\n    value: function dispatch() {\n      var node = this._head;\n\n      if (!node) return false;\n\n      while (node) {\n        if (node._once) this.detach(node);\n        node._fn.apply(node._thisArg, arguments);\n        node = node._next;\n      }\n\n      return true;\n    }\n  }, {\n    key: 'add',\n    value: function add(fn) {\n      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n      if (typeof fn !== 'function') {\n        throw new Error('MiniSignal#add(): First arg must be a Function.');\n      }\n      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));\n    }\n  }, {\n    key: 'once',\n    value: function once(fn) {\n      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n      if (typeof fn !== 'function') {\n        throw new Error('MiniSignal#once(): First arg must be a Function.');\n      }\n      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));\n    }\n  }, {\n    key: 'detach',\n    value: function detach(node) {\n      if (!(node instanceof MiniSignalBinding)) {\n        throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.');\n      }\n      if (node._owner !== this) return this;\n\n      if (node._prev) node._prev._next = node._next;\n      if (node._next) node._next._prev = node._prev;\n\n      if (node === this._head) {\n        this._head = node._next;\n        if (node._next === null) {\n          this._tail = null;\n        }\n      } else if (node === this._tail) {\n        this._tail = node._prev;\n        this._tail._next = null;\n      }\n\n      node._owner = null;\n      return this;\n    }\n  }, {\n    key: 'detachAll',\n    value: function detachAll() {\n      var node = this._head;\n      if (!node) return this;\n\n      this._head = this._tail = null;\n\n      while (node) {\n        node._owner = null;\n        node = node._next;\n      }\n      return this;\n    }\n  }]);\n\n  return MiniSignal;\n})();\n\nMiniSignal.MiniSignalBinding = MiniSignalBinding;\n\nexports['default'] = MiniSignal;\nmodule.exports = exports['default'];\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mini-signals/lib/mini-signals.js\n ** module id = 7\n ** module chunks = 0\n **/","/// <reference path=\"../../typings/index.d.ts\" />\n\n/**\n * An entity is composed from components. As such, it is essentially a collection object for components.\n * Sometimes, the entities in a game will mirror the actual characters and objects in the game, but this\n * is not necessary.\n *\n * <p>Components are simple value objects that contain data relevant to the entity. Entities\n * with similar functionality will have instances of the same components. So we might have\n * a position component</p>\n *\n * <p><code>export class PositionComponent\n * {\n *   public x :number;\n *   public y :number;\n * }</code></p>\n *\n * <p>All entities that have a position in the game world, will have an instance of the\n * position component. Systems operate on entities based on the components they have.</p>\n */\n\nimport {Scene} from './Scene';\nimport {Dictionary} from '../utils/Dictionary';\nconst MiniSignal = require('mini-signals');\n\nexport class Entity {\n\n    private static nameCount = 0;\n    /**\n     * Optional, give the entity a name. This can help with debugging and with serialising the entity.\n     */\n    private _name:string;\n\n    /**\n     * This signal is dispatched when a component is added to the entity.\n     */\n    public componentAdded;\n\n    /**\n     * This signal is dispatched when a component is removed from the entity.\n     */\n    public componentRemoved;\n\n    /**\n     * Dispatched when the name of the entity changes.\n     * Used internally by the engine to track entities based on their names.\n     */\n    public nameChanged;\n\n    public previous:Entity;\n    public next:Entity;\n    private _components:Dictionary;\n    private _addedToScene:Scene;\n\n    constructor(name:string = '') {\n        this._components = new Dictionary();\n        this.componentAdded = new MiniSignal();\n        this.componentRemoved = new MiniSignal();\n        this.nameChanged = new MiniSignal();\n\n        if(name.length > 0) {\n            this._name = name;\n        } else {\n            this._name = 'entity' + (++Entity.nameCount);\n        }\n    }\n\n    /**\n     * All entities have a name. If no name is set, a default name is used. Names are used to\n     * fetch specific entities from the engine, and can also help to identify an entity when debugging.\n     */\n    public get name():string {\n        return this._name;\n    }\n    public set name(value:string) {\n        if(this._name !== value) {\n            var previous:string = this._name;\n            this._name = value;\n            this.nameChanged.dispatch(this, previous);\n        }\n    }\n\n    /**\n     * Add a component to the entity.\n     *\n     * @param component The component object to add.\n     * @param componentClass The class of the component. This is only necessary if the component\n     * extends another component class and you want the framework to treat the component as of\n     * the base class type. If not set, the class type is determined directly from the component.\n     *\n     * @return A reference to the entity. This enables the chaining of calls to add, to make\n     * creating and configuring entities cleaner. e.g.\n     *\n     * <code>var entity : Entity = new Entity()\n     *     .add(new Position(100, 200))\n     *     .add(new Display(new PlayerClip());</code>\n     */\n    public addComponent(component:any, componentClass?):Entity {\n        if(typeof componentClass === 'undefined') {\n            componentClass = component.constructor.name;\n        }\n        if(this._components.has(componentClass)) {\n            this.removeComponent(componentClass);\n        }\n        this._components.add(componentClass, component);\n        this.componentAdded.dispatch(this, componentClass);\n        return this;\n    }\n\n    /**\n     * Remove a component from the entity.\n     *\n     * @param componentClass The class of the component to be removed.\n     * @return the component, or null if the component doesn't exist in the entity\n     */\n    public removeComponent(componentClass):any {\n        let component:any = this._components.getValue(componentClass);\n        if (component) {\n            this._components.remove(componentClass);\n            this.componentRemoved.dispatch(this, componentClass);\n            return component;\n        }\n        return null;\n    }\n\n    /**\n     * Get a component from the entity.\n     *\n     * @param componentClass The class of the component requested.\n     * @return The component, or null if none was found.\n     */\n    public getComponent(componentClass:string):any {\n        return this._components.getValue(componentClass);\n    }\n\n    /**\n     * Does the entity have a component of a particular type.\n     *\n     * @param componentClass The class of the component sought.\n     * @return true if the entity has a component of the type, false if not.\n     */\n    public hasComponent(componentClass:string):boolean {\n        return this._components.has(componentClass);\n    }\n\n    /**\n     * Get all components from the entity.\n     *\n     * @return An array containing all the components that are on the entity.\n     */\n    public getAll():any[] {\n        let componentArray = [];\n\n        this._components.forEach(\n            (componentClass, component) => {\n                componentArray.push(component);\n            }\n        );\n        return componentArray;\n    }\n\n    public set scene(scene:Scene) {\n        this._addedToScene = scene;\n    }\n\n    public toString() {\n        let seen = [];\n        return JSON.stringify(this, function(key, val) {\n            if (typeof val === 'object') {\n                if (seen.indexOf(val) >= 0) {\n                    return;\n                }\n                seen.push(val);\n            }\n            return val;\n        }, 4);\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Entity.ts\n **/","/// <reference path=\"../../typings/index.d.ts\" />\n\n/**\n * The abstract class for a system implementation.\n *\n * <p>A system is part of the core functionality of the game. After a system is added to the engine, its\n * update method will be called on every frame of the engine. When the system is removed from the engine,\n * the update method is no longer called.</p>\n *\n * <p>The aggregate of all systems in the engine is the functionality of the game, with the update\n * methods of those systems collectively constituting the engine update loop. Systems generally operate on\n * node lists - collections of nodes. Each node contains the components from an entity in the engine\n * that match the node.</p>\n */\nexport abstract class System {\n\n    /**\n     * Used internally to manage the list of systems within the engine. The previous system in the list.\n     */\n    public previous:System = null;\n\n    /**\n     * Used internally to manage the list of systems within the engine. The next system in the list.\n     */\n    public next:System = null;\n\n    /**\n     * Used internally to hold the priority of this system within the system list. This is\n     * used to order the systems so they are updated in the correct order.\n     */\n    public priority:number = 0;\n\n    /**\n     * Called just after the system is added to the engine, before any calls to the update method.\n     * Override this method to add your own functionality.\n     *\n     * @param engine The engine the system was added to.\n     */\n    public addToEngine(engine:any):void {\n        throw new Error('Don\\'t call the abstract class directly, this method must be overridden.');\n    }\n\n    /**\n     * Called just after the system is removed from the engine, after all calls to the update method.\n     * Override this method to add your own functionality.\n     *\n     * @param engine The engine the system was removed from.\n     */\n    public removeFromEngine(engine:any):void {\n        throw new Error('Don\\'t call the abstract class directly, this method must be overridden.');\n    }\n\n    /**\n     * After the system is added to the engine, this method is called every frame until the system\n     * is removed from the engine. Override this method to add your own functionality.\n     *\n     * <p>If you need to perform an action outside of the update loop (e.g. you need to change the\n     * systems in the engine and you don't want to do it while they're updating) add a listener to\n     * the engine's updateComplete signal to be notified when the update loop completes.</p>\n     *\n     * @param time The duration, in seconds, of the frame.\n     */\n    public update(time:number) {\n        throw new Error('Don\\'t call the abstract class directly, this method must be overridden.');\n    }\n\n    public is(type) {\n        return type.prototype.isPrototypeOf(this);\n    }\n}\n\nSystem.prototype.previous = null;\nSystem.prototype.next = null;\nSystem.prototype.priority = 0;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/System.ts\n **/","/// <reference path=\"../../typings/index.d.ts\" />\n\n/**\n * The base class for a node.\n *\n * <p>A node is a set of different components that are required by a system.\n * A system can request a collection of nodes from the engine. Subsequently the Engine object creates\n * a node for every entity that has all of the components in the node class and adds these nodes\n * to the list obtained by the system. The engine keeps the list up to date as entities are added\n * to and removed from the engine and as the components on entities change.</p>\n */\n\nexport class Node {\n    /**\n     * The entity whose components are included in the node.\n     */\n    public entity:any = null;\n\n    /**\n     * Used by the NodeList class. The previous node in a node list.\n     */\n    public previous:any = null;\n\n    /**\n     * Used by the NodeList class. The next node in a node list.\n     */\n    public next:any = null;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Node.ts\n **/","/// <reference path=\"../../typings/index.d.ts\" />\n\nimport {LinkedList} from '../utils/LinkedList';\nimport {Dictionary} from '../utils/Dictionary';\nimport {Entity} from './Entity';\nconst MiniSignal = require('mini-signals');\n\nexport class Scene {\n\n    private static nameCount = 0;\n    /**\n     * Optional, give the scene a name. This can help with debugging and with serialising the scenes.\n     */\n    private _name:string;\n\n    /**\n     * This signal is dispatched when a entity is added to the scene.\n     */\n    public entityAdded;\n\n    /**\n     * This signal is dispatched when a entity is removed from the scene.\n     */\n    public entityRemoved;\n\n    /**\n     * Dispatched when the name of the scene changes.\n     * Used internally by the engine to track entities based on their names.\n     */\n    public nameChanged;\n\n    public previous:Scene;\n    public next:Scene;\n\n    private _entities:Dictionary;\n    private _entityList:LinkedList;\n    private _entityNames:Dictionary;\n\n    constructor(name:string = '') {\n        this._entities = new Dictionary();\n        this.entityAdded = new MiniSignal();\n        this.entityRemoved = new MiniSignal();\n        this._entityList = new LinkedList();\n        this._entityNames = new Dictionary();\n        this.nameChanged = new MiniSignal();\n\n        if (name) {\n            this._name = name;\n        } else {\n            this._name = '_scene' + (++Scene.nameCount);\n        }\n    }\n\n    /**\n     * All scenes have a name. If no name is set, a default name is used. Names are used to\n     * fetch specific scenes from the engine, and can also help to identify an entity when debugging.\n     */\n    public get name():string {\n        return this._name;\n    }\n    public set name(value:string) {\n        if(this._name !== value) {\n            var previous:string = this._name;\n            this._name = value;\n            this.nameChanged.dispatch(this, previous);\n        }\n    }\n\n    /**\n     * Add a entity to the scene.\n     *\n     * @param entity The entity object to add.\n     * @param entityClass The class of the entity. This is only necessary if the entity\n     * extends another entity class and you want the framework to treat the entity as of\n     * the base class type. If not set, the class type is determined directly from the entity.\n     *\n     * @return A reference to the scene. This enables the chaining of calls to add, to make\n     * creating and configuring entities cleaner. e.g.\n     *\n     */\n    public addEntity(entity:any, entityClass?):Scene {\n        if (typeof entityClass === 'undefined') {\n            entityClass = entity.constructor;\n        }\n        this._entityList.add(entity);\n        this._entityNames.add(entity.name, entity);\n        this.entityAdded.dispatch(this, entityClass);\n        entity.scene = this;\n        return this;\n    }\n\n    /**\n     * Remove a entity from the scene.\n     *\n     * @param entity The entity to be removed.\n     * @param index The index of the entity in the entityList.\n     */\n    public removeEntity(entity:Entity, index?:number):void {\n        if(typeof index === 'undefined') {\n            for (let i = 0; i < this._entityList.size(); i++) {\n                if(this._entityList.item(i) === entity) {\n                    this._entityList.remove(i);\n                }\n            }\n        } else {\n            this._entityList.remove(index);\n        }\n    }\n\n    /**\n     * Get a entity from the scene.\n     *\n     * @param entityName The class of the entity requested.\n     * @return The entity, or null if none was found.\n     */\n    public getEntityWithName(entityName:any):Entity {\n        for (let i = 0; i < this._entityList.size(); i++) {\n            if (this._entityList.item(i).name === entityName) {\n                return this._entityList.item(i);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get all entities from the scene.\n     *\n     * @return An array containing all the entities that are on the scene.\n     */\n    public getAllEntities():any[] {\n        return this._entityList.toArray();\n    }\n\n    /**\n     * Does the entity have a entity of a particular type.\n     *\n     * @param entityName The class of the entity sought.\n     * @return true if the entity has a entity of the type, false if not.\n     */\n    public hasEntityWithName(entityName:any):boolean {\n        for (let i = 0, len = this._entityList.size(); i < len; i++) {\n            if(this._entityList.item(i).name === entityName) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks the type, if the prototype is matching.\n     *\n     * @return {boolean} Return if the prototypes match.\n     */\n    public is(type):boolean {\n        return type.prototype.isPrototypeOf(this);\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Scene.ts\n **/"],"sourceRoot":""}