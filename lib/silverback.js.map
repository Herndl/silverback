{"version":3,"sources":["webpack:///silverback.js","webpack:///webpack/bootstrap 434fd4eceb5010110764","webpack:///./src/index.ts","webpack:///./src/utils/Dictionary.ts","webpack:///./~/mini-signals/lib/mini-signals.js","webpack:///./src/utils/LinkedList.ts","webpack:///./src/core/ComponentsFamily.ts","webpack:///./src/core/NodeList.ts","webpack:///./src/core/NodePool.ts","webpack:///./src/core/Engine.ts","webpack:///./src/core/Entity.ts","webpack:///./src/core/Node.ts","webpack:///./src/core/Scene.ts","webpack:///./src/core/System.ts"],"names":["exports","modules","__webpack_require__","moduleId","installedModules","module","id","loaded","call","m","c","p","__export","hasOwnProperty","Dictionary","Dictionary.constructor","Dictionary.add","Dictionary.remove","Dictionary.getValue","Dictionary.getIndex","Dictionary.has","Dictionary.values","Dictionary.forEach","_classCallCheck","instance","Constructor","TypeError","_addMiniSignalBinding","self","node","_head","_tail","_next","_prev","_owner","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","MiniSignalBinding","fn","once","thisArg","undefined","this","_fn","_once","_thisArg","detach","MiniSignal","exists","arguments","ee","push","Error","apply","LinkedList","LinkedList.constructor","LinkedList.add","LinkedList.item","LinkedList.remove","LinkedList.size","LinkedList.toArray","LinkedList.toString","LinkedList.get","NodePool_1","NodeList_1","Dictionary_1","ComponentsFamily","ComponentsFamily.constructor","get","ComponentsFamily.nodeList","ComponentsFamily.newEntity","ComponentsFamily.componentAddedToEntity","ComponentsFamily.componentRemovedFromEntity","ComponentsFamily.removeEntity","ComponentsFamily.addIfMatch","componentName","entity","componentClass","ComponentsFamily.removeIfMatch","ComponentsFamily._releaseNodePoolCache","ComponentsFamily.cleanUp","NodeList","NodeList.constructor","NodeList.add","NodeList.remove","NodeList.removeAll","NodeList.empty","NodeList.swap","NodeList.insertionSort","NodeList.mergeSort","NodeList._merge","NodePool","NodePool.constructor","NodePool.get","NodePool.dispose","NodePool.cache","NodePool.releaseCache","LinkedList_1","ComponentsFamily_1","Engine","Engine.constructor","Engine.entities","Engine.scenes","Engine.systems","Engine.addEntity","Engine.removeEntity","Engine.getEntityByName","Engine.removeAllEntities","Engine.addScene","Engine.removeScene","Engine.removeAllScenes","Engine.getSceneByName","Engine.getScene","Engine.getNodeList","Engine.releaseNodeList","Engine.addSystem","Engine.getSystem","Engine.removeSystem","Engine.removeAllSystems","Engine.update","Engine._entityNameChanged","Engine._sceneNameChanged","Engine._componentAdded","Engine._componentRemoved","Entity","Entity.constructor","Entity.name","set","Entity.add","Entity.remove","Entity.get","Entity.getAll","Entity.has","Entity.scene","Node","Node.constructor","Scene","Scene.constructor","Scene.name","Scene.addEntity","Scene.removeEntity","Scene.getEntityWithName","Scene.getEntityWithComponent","Scene.getAllEntity","Scene.hasEntity","Scene.is","System","System.constructor","System.addToEngine","System.removeFromEngine","System.update","System.is","previous","next","priority"],"mappings":"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","file":"silverback.js","sourcesContent":["exports[true] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/lib/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(1));\n\t__export(__webpack_require__(3));\n\t__export(__webpack_require__(7));\n\t__export(__webpack_require__(8));\n\t__export(__webpack_require__(11));\n\t__export(__webpack_require__(9));\n\t__export(__webpack_require__(5));\n\t__export(__webpack_require__(6));\n\t__export(__webpack_require__(10));\n\t__export(__webpack_require__(4));\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tvar Dictionary = (function () {\n\t    function Dictionary() {\n\t        this._keys = [];\n\t        this._values = [];\n\t    }\n\t    Dictionary.prototype.add = function (key, value) {\n\t        var keyIndex = this.getIndex(key);\n\t        if (keyIndex >= 0) {\n\t            this._values[keyIndex] = value;\n\t        }\n\t        else {\n\t            this._keys.push(key);\n\t            this._values.push(value);\n\t        }\n\t    };\n\t    Dictionary.prototype.remove = function (key) {\n\t        var keyIndex = this.getIndex(key);\n\t        if (keyIndex >= 0) {\n\t            var removedValue = this._values[keyIndex];\n\t            this._keys.splice(keyIndex, 1);\n\t            this._values.splice(keyIndex, 1);\n\t            return removedValue;\n\t        }\n\t        else {\n\t            throw 'Key does not exist';\n\t        }\n\t    };\n\t    Dictionary.prototype.getValue = function (key) {\n\t        var value = null;\n\t        var keyIndex = this.getIndex(key);\n\t        if (keyIndex >= 0) {\n\t            value = this._values[keyIndex];\n\t        }\n\t        return value;\n\t    };\n\t    Dictionary.prototype.getIndex = function (testKey) {\n\t        var len = this._keys.length;\n\t        var key;\n\t        for (var i = 0; i < len; ++i) {\n\t            key = this._keys[i];\n\t            if (key === testKey) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    Dictionary.prototype.has = function (testKey) {\n\t        var len = this._keys.length;\n\t        var key;\n\t        for (var i = 0; i < len; ++i) {\n\t            key = this._keys[i];\n\t            if (key === testKey) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t    Dictionary.prototype.values = function () {\n\t        var len = this._keys.length;\n\t        var key;\n\t        var value;\n\t        var arValue = [];\n\t        for (var i = 0; i < len; ++i) {\n\t            key = this._keys[i];\n\t            value = this._values[i];\n\t            arValue.push(value);\n\t        }\n\t        return arValue;\n\t    };\n\t    Dictionary.prototype.forEach = function (action) {\n\t        var len = this._keys.length;\n\t        var key;\n\t        var value;\n\t        for (var i = 0; i < len; ++i) {\n\t            key = this._keys[i];\n\t            value = this._values[i];\n\t            var breakHere = action(key, value);\n\t            if (breakHere === 'return') {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t    return Dictionary;\n\t})();\n\texports.Dictionary = Dictionary;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar MiniSignalBinding = (function () {\n\t  function MiniSignalBinding(fn, once, thisArg) {\n\t    if (once === undefined) once = false;\n\t\n\t    _classCallCheck(this, MiniSignalBinding);\n\t\n\t    this._fn = fn;\n\t    this._once = once;\n\t    this._thisArg = thisArg;\n\t    this._next = this._prev = this._owner = null;\n\t  }\n\t\n\t  _createClass(MiniSignalBinding, [{\n\t    key: 'detach',\n\t    value: function detach() {\n\t      if (this._owner === null) return false;\n\t      this._owner.detach(this);\n\t      return true;\n\t    }\n\t  }]);\n\t\n\t  return MiniSignalBinding;\n\t})();\n\t\n\tfunction _addMiniSignalBinding(self, node) {\n\t  if (!self._head) {\n\t    self._head = node;\n\t    self._tail = node;\n\t  } else {\n\t    self._tail._next = node;\n\t    node._prev = self._tail;\n\t    self._tail = node;\n\t  }\n\t\n\t  node._owner = self;\n\t\n\t  return node;\n\t}\n\t\n\tvar MiniSignal = (function () {\n\t  function MiniSignal() {\n\t    _classCallCheck(this, MiniSignal);\n\t\n\t    this._head = this._tail = undefined;\n\t  }\n\t\n\t  _createClass(MiniSignal, [{\n\t    key: 'handlers',\n\t    value: function handlers() {\n\t      var exists = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\t\n\t      var node = this._head;\n\t\n\t      if (exists) return !!node;\n\t\n\t      var ee = [];\n\t\n\t      while (node) {\n\t        ee.push(node);\n\t        node = node._next;\n\t      }\n\t\n\t      return ee;\n\t    }\n\t  }, {\n\t    key: 'has',\n\t    value: function has(node) {\n\t      if (!(node instanceof MiniSignalBinding)) {\n\t        throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.');\n\t      }\n\t\n\t      return node._owner === this;\n\t    }\n\t  }, {\n\t    key: 'dispatch',\n\t    value: function dispatch() {\n\t      var node = this._head;\n\t\n\t      if (!node) return false;\n\t\n\t      while (node) {\n\t        node._fn.apply(node._thisArg, arguments);\n\t        if (node._once) this.detach(node);\n\t        node = node._next;\n\t      }\n\t\n\t      return true;\n\t    }\n\t  }, {\n\t    key: 'add',\n\t    value: function add(fn) {\n\t      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\t\n\t      if (typeof fn !== 'function') {\n\t        throw new Error('MiniSignal#add(): First arg must be a Function.');\n\t      }\n\t      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));\n\t    }\n\t  }, {\n\t    key: 'once',\n\t    value: function once(fn) {\n\t      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\t\n\t      if (typeof fn !== 'function') {\n\t        throw new Error('MiniSignal#once(): First arg must be a Function.');\n\t      }\n\t      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));\n\t    }\n\t  }, {\n\t    key: 'detach',\n\t    value: function detach(node) {\n\t      if (!(node instanceof MiniSignalBinding)) {\n\t        throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.');\n\t      }\n\t      if (node._owner !== this) return this;\n\t\n\t      if (node._prev) node._prev._next = node._next;\n\t      if (node._next) node._next._prev = node._prev;\n\t\n\t      if (node === this._head) {\n\t        this._head = node._next;\n\t        if (node._next === null) {\n\t          this._tail = null;\n\t        }\n\t      } else if (node === this._tail) {\n\t        this._tail = node._prev;\n\t        this._tail._next = null;\n\t      }\n\t\n\t      node._owner = null;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'detachAll',\n\t    value: function detachAll() {\n\t      var node = this._head;\n\t      if (!node) return this;\n\t\n\t      this._head = this._tail = null;\n\t\n\t      while (node) {\n\t        node._owner = null;\n\t        node = node._next;\n\t      }\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return MiniSignal;\n\t})();\n\t\n\tMiniSignal.MiniSignalBinding = MiniSignalBinding;\n\t\n\texports['default'] = MiniSignal;\n\tmodule.exports = exports['default'];\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tvar LinkedList = (function () {\n\t    function LinkedList() {\n\t        this._head = null;\n\t        this._tail = null;\n\t        this._length = 0;\n\t    }\n\t    LinkedList.prototype.add = function (data) {\n\t        var node = {\n\t            data: data,\n\t            next: null,\n\t            prev: null\n\t        };\n\t        if (this._length === 0) {\n\t            this._head = node;\n\t            this._tail = node;\n\t        }\n\t        else {\n\t            this._tail.next = node;\n\t            node.prev = this._tail;\n\t            this._tail = node;\n\t        }\n\t        this._length++;\n\t    };\n\t    LinkedList.prototype.item = function (index) {\n\t        if (index > -1 && index < this._length) {\n\t            var current = this._head, i = 0;\n\t            while (i++ < index) {\n\t                current = current.next;\n\t            }\n\t            return current.data;\n\t        }\n\t        else {\n\t            return null;\n\t        }\n\t    };\n\t    LinkedList.prototype.remove = function (index) {\n\t        if (index > -1 && index < this._length) {\n\t            var current = this._head, i = 0;\n\t            if (index === 0) {\n\t                this._head = current.next;\n\t                if (!this._head) {\n\t                    this._tail = null;\n\t                }\n\t                else {\n\t                    this._head.prev = null;\n\t                }\n\t            }\n\t            else if (index === this._length - 1) {\n\t                current = this._tail;\n\t                this._tail = current.prev;\n\t                this._tail.next = null;\n\t            }\n\t            else {\n\t                while (i++ < index) {\n\t                    current = current.next;\n\t                }\n\t                current.prev.next = current.next;\n\t                current.next.prev = current.prev;\n\t            }\n\t            this._length--;\n\t            return current.data;\n\t        }\n\t        else {\n\t            return null;\n\t        }\n\t    };\n\t    LinkedList.prototype.size = function () {\n\t        return this._length;\n\t    };\n\t    LinkedList.prototype.toArray = function () {\n\t        var result = [], current = this._head;\n\t        while (current) {\n\t            result.push(current.data);\n\t            current = current.next;\n\t        }\n\t        return result;\n\t    };\n\t    LinkedList.prototype.toString = function () {\n\t        return this.toArray().toString();\n\t    };\n\t    LinkedList.prototype.get = function (type) {\n\t        var current = this._head;\n\t        if (typeof current.data.is === 'function') {\n\t            while (current) {\n\t                if (current.data.is(type)) {\n\t                    return current.data;\n\t                }\n\t                current = current.next;\n\t            }\n\t        }\n\t        else {\n\t            console.log('This type <' + type + '> does not support this method.');\n\t        }\n\t        return null;\n\t    };\n\t    return LinkedList;\n\t})();\n\texports.LinkedList = LinkedList;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar NodePool_1 = __webpack_require__(6);\n\tvar NodeList_1 = __webpack_require__(5);\n\tvar Dictionary_1 = __webpack_require__(1);\n\tvar ComponentsFamily = (function () {\n\t    function ComponentsFamily(nodeClass, engine) {\n\t        this._nodeClass = nodeClass;\n\t        this._engine = engine;\n\t        this._nodes = new NodeList_1.NodeList();\n\t        this._entities = new Dictionary_1.Dictionary();\n\t        this._components = new Dictionary_1.Dictionary();\n\t        var nodeClassPrototype = this._nodeClass.prototype;\n\t        for (var property in nodeClassPrototype) {\n\t            if (nodeClassPrototype.hasOwnProperty(property) &&\n\t                property !== 'types' &&\n\t                property !== 'next' &&\n\t                property !== 'previous' &&\n\t                property !== 'constructor' &&\n\t                property !== 'super' &&\n\t                property !== 'extend' &&\n\t                property !== 'entity') {\n\t                var componentObject = nodeClassPrototype.types[property];\n\t                this._components.add(componentObject, property);\n\t            }\n\t        }\n\t        this._nodePool = new NodePool_1.NodePool(this._nodeClass, this._components);\n\t        this._nodePool.dispose(this._nodePool.get());\n\t    }\n\t    Object.defineProperty(ComponentsFamily.prototype, \"nodeList\", {\n\t        get: function () {\n\t            return this._nodes;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ComponentsFamily.prototype.newEntity = function (entity) {\n\t        this.addIfMatch(entity);\n\t    };\n\t    ComponentsFamily.prototype.componentAddedToEntity = function (entity, componentClass) {\n\t        this.addIfMatch(entity);\n\t    };\n\t    ComponentsFamily.prototype.componentRemovedFromEntity = function (entity, componentClass) {\n\t        if (this._components.has(componentClass)) {\n\t            this.removeIfMatch(entity);\n\t        }\n\t    };\n\t    ComponentsFamily.prototype.removeEntity = function (entity) {\n\t        this.removeIfMatch(entity);\n\t    };\n\t    ComponentsFamily.prototype.addIfMatch = function (entity) {\n\t        if (!this._entities.has(entity)) {\n\t            this._components.forEach(function (componentClass) {\n\t                if (!entity.has(componentClass)) {\n\t                    return;\n\t                }\n\t            });\n\t            var node = this._nodePool.get();\n\t            node.entity = entity;\n\t            this._components.forEach(function (componentClass, componentName) {\n\t                node[componentName] = entity.get(componentClass);\n\t            });\n\t            this._entities.add(entity, node);\n\t            this._nodes.add(node);\n\t        }\n\t    };\n\t    ComponentsFamily.prototype.removeIfMatch = function (entity) {\n\t        if (this._entities.getValue(entity)) {\n\t            var node = this._entities.getValue(entity);\n\t            this._entities.remove(entity);\n\t            this._nodes.remove(node);\n\t            if (this._engine.updating) {\n\t                this._nodePool.cache(node);\n\t                this._engine.updateComplete.add(this._releaseNodePoolCache, this);\n\t            }\n\t            else {\n\t                this._nodePool.dispose(node);\n\t            }\n\t        }\n\t    };\n\t    ComponentsFamily.prototype._releaseNodePoolCache = function () {\n\t        this._engine.updateComplete.detachAll();\n\t        this._nodePool.releaseCache();\n\t    };\n\t    ComponentsFamily.prototype.cleanUp = function () {\n\t        for (var node = this._nodes.head; node; node = node.next) {\n\t            this._entities.remove(node.entity);\n\t        }\n\t        this._nodes.removeAll();\n\t    };\n\t    return ComponentsFamily;\n\t})();\n\texports.ComponentsFamily = ComponentsFamily;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar MiniSignal = __webpack_require__(2);\n\tvar NodeList = (function () {\n\t    function NodeList() {\n\t        this.head = null;\n\t        this.tail = null;\n\t        this.nodeAdded = new MiniSignal();\n\t        this.nodeRemoved = new MiniSignal();\n\t    }\n\t    NodeList.prototype.add = function (node) {\n\t        if (!this.head) {\n\t            this.head = this.tail = node;\n\t            node.next = node.previous = null;\n\t        }\n\t        else {\n\t            this.tail.next = node;\n\t            node.previous = this.tail;\n\t            node.next = null;\n\t            this.tail = node;\n\t        }\n\t        this.nodeAdded.dispatch(node);\n\t    };\n\t    NodeList.prototype.remove = function (node) {\n\t        if (this.head === node) {\n\t            this.head = this.head.next;\n\t        }\n\t        if (this.tail === node) {\n\t            this.tail = this.tail.previous;\n\t        }\n\t        if (node.previous) {\n\t            node.previous.next = node.next;\n\t        }\n\t        if (node.next) {\n\t            node.next.previous = node.previous;\n\t        }\n\t        this.nodeRemoved.dispatch(node);\n\t    };\n\t    NodeList.prototype.removeAll = function () {\n\t        while (this.head) {\n\t            var node = this.head;\n\t            this.head = node.next;\n\t            node.previous = null;\n\t            node.next = null;\n\t            this.nodeRemoved.dispatch(node);\n\t        }\n\t        this.tail = null;\n\t    };\n\t    NodeList.prototype.empty = function () {\n\t        return this.head === null;\n\t    };\n\t    NodeList.prototype.swap = function (node1, node2) {\n\t        if (node1.previous === node2) {\n\t            node1.previous = node2.previous;\n\t            node2.previous = node1;\n\t            node2.next = node1.next;\n\t            node1.next = node2;\n\t        }\n\t        else if (node2.previous === node1) {\n\t            node2.previous = node1.previous;\n\t            node1.previous = node2;\n\t            node1.next = node2.next;\n\t            node2.next = node1;\n\t        }\n\t        else {\n\t            var temp = node1.previous;\n\t            node1.previous = node2.previous;\n\t            node2.previous = temp;\n\t            temp = node1.next;\n\t            node1.next = node2.next;\n\t            node2.next = temp;\n\t        }\n\t        if (this.head === node1) {\n\t            this.head = node2;\n\t        }\n\t        else if (this.head === node2) {\n\t            this.head = node1;\n\t        }\n\t        if (this.tail === node1) {\n\t            this.tail = node2;\n\t        }\n\t        else if (this.tail === node2) {\n\t            this.tail = node1;\n\t        }\n\t        if (node1.previous) {\n\t            node1.previous.next = node1;\n\t        }\n\t        if (node2.previous) {\n\t            node2.previous.next = node2;\n\t        }\n\t        if (node1.next) {\n\t            node1.next.previous = node1;\n\t        }\n\t        if (node2.next) {\n\t            node2.next.previous = node2;\n\t        }\n\t    };\n\t    NodeList.prototype.insertionSort = function (sortFunction) {\n\t        if (this.head === this.tail) {\n\t            return;\n\t        }\n\t        var remains = this.head.next;\n\t        for (var node = remains; node; node = remains) {\n\t            remains = node.next;\n\t            for (var other = node.previous; other; other = other.previous) {\n\t                if (sortFunction(node, other) >= 0) {\n\t                    if (node !== other.next) {\n\t                        if (this.tail === node) {\n\t                            this.tail = node.previous;\n\t                        }\n\t                        node.previous.next = node.next;\n\t                        if (node.next) {\n\t                            node.next.previous = node.previous;\n\t                        }\n\t                        node.next = other.next;\n\t                        node.previous = other;\n\t                        node.next.previous = node;\n\t                        other.next = node;\n\t                    }\n\t                    break;\n\t                }\n\t            }\n\t            if (!other) {\n\t                if (this.tail === node) {\n\t                    this.tail = node.previous;\n\t                }\n\t                node.previous.next = node.next;\n\t                if (node.next) {\n\t                    node.next.previous = node.previous;\n\t                }\n\t                node.next = this.head;\n\t                this.head.previous = node;\n\t                node.previous = null;\n\t                this.head = node;\n\t            }\n\t        }\n\t    };\n\t    NodeList.prototype.mergeSort = function (sortFunction) {\n\t        if (this.head === this.tail) {\n\t            return;\n\t        }\n\t        var lists;\n\t        var start = this.head;\n\t        var end;\n\t        while (start) {\n\t            end = start;\n\t            while (end.next && sortFunction(end, end.next) <= 0) {\n\t                end = end.next;\n\t            }\n\t            var next = end.next;\n\t            start.previous = end.next = null;\n\t            lists.push(start);\n\t            start = next;\n\t        }\n\t        while (lists.length > 1) {\n\t        }\n\t        this.tail = this.head = lists[0];\n\t        while (this.tail.next) {\n\t            this.tail = this.tail.next;\n\t        }\n\t    };\n\t    NodeList.prototype._merge = function (head1, head2, sortFunction) {\n\t        var node;\n\t        var head;\n\t        if (sortFunction(head1, head2) <= 0) {\n\t            head = node = head1;\n\t            head1 = head1.next;\n\t        }\n\t        else {\n\t            head = node = head2;\n\t            head2 = head2.next;\n\t        }\n\t        while (head1 && head2) {\n\t            if (sortFunction(head1, head2) <= 0) {\n\t                node.next = head1;\n\t                head1.previous = node;\n\t                node = head1;\n\t                head1 = head1.next;\n\t            }\n\t            else {\n\t                node.next = head2;\n\t                head2.previous = node;\n\t                node = head2;\n\t                head2 = head2.next;\n\t            }\n\t        }\n\t        if (head1) {\n\t            node.next = head1;\n\t            head1.previous = node;\n\t        }\n\t        else {\n\t            node.next = head2;\n\t            head2.previous = node;\n\t        }\n\t        return head;\n\t    };\n\t    return NodeList;\n\t})();\n\texports.NodeList = NodeList;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tvar NodePool = (function () {\n\t    function NodePool(nodeClass, components) {\n\t        this._nodeClass = nodeClass;\n\t        this._components = components;\n\t    }\n\t    NodePool.prototype.get = function () {\n\t        if (this._tail) {\n\t            var node = this._tail;\n\t            this._tail = this._tail.previous;\n\t            node.previous = null;\n\t            return node;\n\t        }\n\t        else {\n\t            var newNode = new this._nodeClass;\n\t            return newNode;\n\t        }\n\t    };\n\t    NodePool.prototype.dispose = function (node) {\n\t        this._components.forEach(function (componentClass, componentName) {\n\t            node[componentName] = null;\n\t        });\n\t        node.entity = null;\n\t        node.next = null;\n\t        node.previous = this._tail;\n\t        this._tail = node;\n\t    };\n\t    NodePool.prototype.cache = function (node) {\n\t        node.previous = this._cacheTail;\n\t        this._cacheTail = node;\n\t    };\n\t    NodePool.prototype.releaseCache = function () {\n\t        while (this._cacheTail) {\n\t            var node = this._cacheTail;\n\t            this._cacheTail = node.previous;\n\t            node.next = null;\n\t            node.previous = this._tail;\n\t            this._tail = node;\n\t        }\n\t    };\n\t    return NodePool;\n\t})();\n\texports.NodePool = NodePool;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Dictionary_1 = __webpack_require__(1);\n\tvar LinkedList_1 = __webpack_require__(3);\n\tvar ComponentsFamily_1 = __webpack_require__(4);\n\tvar MiniSignal = __webpack_require__(2);\n\tvar Engine = (function () {\n\t    function Engine() {\n\t        this._systemList = new LinkedList_1.LinkedList();\n\t        this._entityList = new LinkedList_1.LinkedList();\n\t        this._sceneList = new LinkedList_1.LinkedList();\n\t        this._entityNames = new Dictionary_1.Dictionary();\n\t        this._sceneNames = new Dictionary_1.Dictionary();\n\t        this._families = new Dictionary_1.Dictionary();\n\t        this.updateComplete = new MiniSignal();\n\t        this.familyClass = ComponentsFamily_1.ComponentsFamily;\n\t    }\n\t    Object.defineProperty(Engine.prototype, \"entities\", {\n\t        get: function () {\n\t            return this._entityList.toArray();\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Engine.prototype, \"scenes\", {\n\t        get: function () {\n\t            return this._sceneList.toArray();\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Engine.prototype, \"systems\", {\n\t        get: function () {\n\t            return this._systemList.toArray();\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Engine.prototype.addEntity = function (entity) {\n\t        if (this._entityNames.has(entity.name)) {\n\t            throw new Error('The entity name ' + entity.name + ' is already in use by another entity.');\n\t        }\n\t        this._entityList.add(entity);\n\t        this._entityNames.add(entity.name, entity);\n\t        entity.componentAdded.add(this._componentAdded, this);\n\t        entity.componentRemoved.add(this._componentRemoved, this);\n\t        entity.nameChanged.add(this._entityNameChanged, this);\n\t        this._families.forEach(function (nodeObject, family) {\n\t            family.newEntity(entity);\n\t        });\n\t    };\n\t    Engine.prototype.removeEntity = function (entity, index) {\n\t        entity.componentAdded.detachAll();\n\t        entity.componentRemoved.detachAll();\n\t        entity.nameChanged.detachAll();\n\t        this._families.forEach(function (nodeObject, family) {\n\t            family.removeEntity(entity);\n\t        });\n\t        this._entityNames.remove(entity.name);\n\t        this._entityList.remove(index);\n\t    };\n\t    Engine.prototype.getEntityByName = function (name) {\n\t        if (this._entityNames.has(name)) {\n\t            return this._entityNames.getValue(name);\n\t        }\n\t        return null;\n\t    };\n\t    Engine.prototype.removeAllEntities = function () {\n\t        var listSize = this._entityList.size() - 1;\n\t        for (var i = listSize; i >= 0; i--) {\n\t            this.removeEntity(this._entityList.item(i), i);\n\t        }\n\t    };\n\t    Engine.prototype.addScene = function (scene) {\n\t        this._sceneList.add(scene);\n\t        this._sceneNames.add(scene.name, scene);\n\t        scene.nameChanged.add(this._sceneNameChanged, this);\n\t    };\n\t    Engine.prototype.removeScene = function (scene, index) {\n\t        if (typeof index === 'undefined') {\n\t            for (var i = 0; i < this._sceneList.size(); i++) {\n\t                if (this._sceneList.item(i) === scene) {\n\t                    this._sceneList.remove(i);\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            this._sceneList.remove(index);\n\t        }\n\t        this._sceneNames.remove(scene.name);\n\t        scene.nameChanged.detachAll();\n\t    };\n\t    Engine.prototype.removeAllScenes = function () {\n\t        var listSize = this._sceneList.size() - 1;\n\t        for (var i = listSize; i >= 0; i--) {\n\t            this.removeScene(this._sceneList.item(i), i);\n\t        }\n\t    };\n\t    Engine.prototype.getSceneByName = function (name) {\n\t        if (this._sceneNames.has(name)) {\n\t            return this._sceneNames.getValue(name);\n\t        }\n\t        return null;\n\t    };\n\t    Engine.prototype.getScene = function (type) {\n\t        return this._sceneList.get(type);\n\t    };\n\t    Engine.prototype.getNodeList = function (nodeClass) {\n\t        if (this._families.has(nodeClass)) {\n\t            return this._families.getValue(nodeClass)._nodes;\n\t        }\n\t        var family = new this.familyClass(nodeClass, this);\n\t        this._families.add(nodeClass, family);\n\t        for (var i = 0; i < this._entityList.size(); i++) {\n\t            family.newEntity(this._entityList.item(i));\n\t        }\n\t        return family.nodeList;\n\t    };\n\t    Engine.prototype.releaseNodeList = function (nodeClass) {\n\t        if (this._families.has(nodeClass)) {\n\t            this._families.getValue(nodeClass).cleanUp();\n\t        }\n\t        else {\n\t            throw new Error('The given nodeClass was not found and can not be released.');\n\t        }\n\t        this._families.remove(nodeClass);\n\t    };\n\t    Engine.prototype.addSystem = function (system, priority) {\n\t        system.priority = priority;\n\t        system.addToEngine(this);\n\t        this._systemList.add(system);\n\t    };\n\t    Engine.prototype.getSystem = function (type) {\n\t        return this._systemList.get(type);\n\t    };\n\t    Engine.prototype.removeSystem = function (system, index) {\n\t        if (typeof index === 'undefined') {\n\t            for (var i = 0; i < this._systemList.size(); i++) {\n\t                if (this._systemList.item(i) === system) {\n\t                    this._systemList.remove(i);\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            this._systemList.remove(index);\n\t        }\n\t        system.removeFromEngine(this);\n\t    };\n\t    Engine.prototype.removeAllSystems = function () {\n\t        var listSize = this._systemList.size() - 1;\n\t        for (var i = listSize; i >= 0; i--) {\n\t            this.removeSystem(this._systemList.item(i), i);\n\t        }\n\t    };\n\t    Engine.prototype.update = function (time) {\n\t        this.updating = true;\n\t        var systemSize = this._systemList.size();\n\t        for (var i = 0; i < systemSize; i++) {\n\t            this._systemList.item(i).update(time);\n\t        }\n\t        this.updating = false;\n\t        this.updateComplete.dispatch();\n\t    };\n\t    Engine.prototype._entityNameChanged = function (entity, oldName) {\n\t        if (this._entityNames.has(oldName)) {\n\t            this._entityNames.remove(oldName);\n\t            this._entityNames.add(entity.name, entity);\n\t        }\n\t        else {\n\t            throw new Error('The given name was not found in the entity list.');\n\t        }\n\t    };\n\t    Engine.prototype._sceneNameChanged = function (scene, oldName) {\n\t        if (this._sceneNames.has(oldName)) {\n\t            this._sceneNames.remove(oldName);\n\t            this._sceneNames.add(scene.name, scene);\n\t        }\n\t        else {\n\t            throw new Error('The given name was not found in the scene list.');\n\t        }\n\t    };\n\t    Engine.prototype._componentAdded = function (entity, componentClass) {\n\t        this._families.forEach(function (nodeObject, family) {\n\t            family.componentAddedToEntity(entity, componentClass);\n\t        });\n\t    };\n\t    Engine.prototype._componentRemoved = function (entity, componentClass) {\n\t        this._families.forEach(function (nodeObject, family) {\n\t            family.componentRemovedFromEntity(entity, componentClass);\n\t        });\n\t    };\n\t    return Engine;\n\t})();\n\texports.Engine = Engine;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Dictionary_1 = __webpack_require__(1);\n\tvar MiniSignal = __webpack_require__(2);\n\tvar Entity = (function () {\n\t    function Entity(name) {\n\t        if (name === void 0) { name = ''; }\n\t        this._components = new Dictionary_1.Dictionary();\n\t        this.componentAdded = new MiniSignal();\n\t        this.componentRemoved = new MiniSignal();\n\t        this.nameChanged = new MiniSignal();\n\t        if (name.length > 0) {\n\t            this._name = name;\n\t        }\n\t        else {\n\t            this._name = '_entity' + (++Entity.nameCount);\n\t        }\n\t    }\n\t    Object.defineProperty(Entity.prototype, \"name\", {\n\t        get: function () {\n\t            return this._name;\n\t        },\n\t        set: function (value) {\n\t            if (this._name !== value) {\n\t                var previous = this._name;\n\t                this._name = value;\n\t                this.nameChanged.dispatch(this, previous);\n\t            }\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Entity.prototype.add = function (component, componentClass) {\n\t        if (typeof componentClass === 'undefined') {\n\t            componentClass = component.constructor;\n\t        }\n\t        if (this._components.has(componentClass)) {\n\t            this.remove(componentClass);\n\t        }\n\t        this._components.add(componentClass, component);\n\t        this.componentAdded.dispatch(this, componentClass);\n\t        return this;\n\t    };\n\t    Entity.prototype.remove = function (componentClass) {\n\t        var component = this._components.getValue(componentClass);\n\t        if (component) {\n\t            this._components.remove(componentClass);\n\t            this.componentRemoved.dispatch(this, componentClass);\n\t            return component;\n\t        }\n\t        return null;\n\t    };\n\t    Entity.prototype.get = function (componentClass) {\n\t        return this._components.getValue(componentClass);\n\t    };\n\t    Entity.prototype.getAll = function () {\n\t        var componentArray = [];\n\t        this._components.forEach(function (componentClass, component) {\n\t            componentArray.push(component);\n\t        });\n\t        return componentArray;\n\t    };\n\t    Entity.prototype.has = function (componentClass) {\n\t        return this._components.has(componentClass);\n\t    };\n\t    Object.defineProperty(Entity.prototype, \"scene\", {\n\t        set: function (scene) {\n\t            this._addedToScene = scene;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Entity.nameCount = 0;\n\t    return Entity;\n\t})();\n\texports.Entity = Entity;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tvar Node = (function () {\n\t    function Node() {\n\t        this.entity = null;\n\t        this.previous = null;\n\t        this.next = null;\n\t    }\n\t    return Node;\n\t})();\n\texports.Node = Node;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar LinkedList_1 = __webpack_require__(3);\n\tvar Dictionary_1 = __webpack_require__(1);\n\tvar MiniSignal = __webpack_require__(2);\n\tvar Scene = (function () {\n\t    function Scene(name) {\n\t        if (name === void 0) { name = ''; }\n\t        this._entities = new Dictionary_1.Dictionary();\n\t        this.entityAdded = new MiniSignal();\n\t        this.entityRemoved = new MiniSignal();\n\t        this._entityList = new LinkedList_1.LinkedList();\n\t        this.nameChanged = new MiniSignal();\n\t        if (name) {\n\t            this._name = name;\n\t        }\n\t        else {\n\t            this._name = '_scene' + (++Scene.nameCount);\n\t        }\n\t    }\n\t    Object.defineProperty(Scene.prototype, \"name\", {\n\t        get: function () {\n\t            return this._name;\n\t        },\n\t        set: function (value) {\n\t            if (this._name !== value) {\n\t                var previous = this._name;\n\t                this._name = value;\n\t                this.nameChanged.dispatch(this, previous);\n\t            }\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Scene.prototype.addEntity = function (entity, entityClass) {\n\t        if (typeof entityClass === 'undefined') {\n\t            entityClass = entity.constructor;\n\t        }\n\t        this._entityList.add(entity);\n\t        this.entityAdded.dispatch(this, entityClass);\n\t        entity.scene = this;\n\t        return this;\n\t    };\n\t    Scene.prototype.removeEntity = function (entity) {\n\t        this._entityList.remove(entity);\n\t    };\n\t    Scene.prototype.getEntityWithName = function (entityName) {\n\t        for (var i = 0; i < this._entityList.size(); i++) {\n\t            if (this._entityList.item(i).name === entityName) {\n\t                return this._entityList.item(i);\n\t            }\n\t        }\n\t    };\n\t    Scene.prototype.getEntityWithComponent = function (_component, _componentClass) {\n\t        for (var i = 0; i < this._entityList.size(); i++) {\n\t            if (this._entityList.item(i).has(_componentClass)) {\n\t                if (this._entityList.item(i).get(_componentClass).displayObject === _component) {\n\t                    return this._entityList.item(i);\n\t                }\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t    Scene.prototype.getAllEntity = function () {\n\t        var entityArray = [];\n\t        this._entities.forEach(function (entityClass, entity) {\n\t            entityArray.push(entity);\n\t        });\n\t        return entityArray;\n\t    };\n\t    Scene.prototype.hasEntity = function (entityClass) {\n\t        return this._entities.has(entityClass);\n\t    };\n\t    Scene.prototype.is = function (type) {\n\t        return type.prototype.isPrototypeOf(this);\n\t    };\n\t    Scene.nameCount = 0;\n\t    return Scene;\n\t})();\n\texports.Scene = Scene;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tvar System = (function () {\n\t    function System() {\n\t        this.previous = null;\n\t        this.next = null;\n\t        this.priority = 0;\n\t    }\n\t    System.prototype.addToEngine = function (engine) {\n\t        throw new Error('Don\\'t call the abstract class directly, this method must be overridden.');\n\t    };\n\t    System.prototype.removeFromEngine = function (engine) {\n\t        throw new Error('Don\\'t call the abstract class directly, this method must be overridden.');\n\t    };\n\t    System.prototype.update = function (time) {\n\t        throw new Error('Don\\'t call the abstract class directly, this method must be overridden.');\n\t    };\n\t    System.prototype.is = function (type) {\n\t        return type.prototype.isPrototypeOf(this);\n\t    };\n\t    return System;\n\t})();\n\texports.System = System;\n\tSystem.prototype.previous = null;\n\tSystem.prototype.next = null;\n\tSystem.prototype.priority = 0;\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** silverback.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/lib/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 434fd4eceb5010110764\n **/","/**\n * @author       Stefan Herndlbauer <sherndlbauer@gorillabyte.com>\n * @copyright    2015 Gorillabyte\n * @license      {@link http://repo.gorillabyte.com/cos/silverback/blob/master/README.md|LGPL License}\n *\n * */\n\n // Core components of the engine\nexport * from './utils/Dictionary';\nexport * from './utils/LinkedList';\n\nexport * from './core/Engine';\nexport * from './core/Entity';\nexport * from './core/System';\nexport * from './core/Node';\nexport * from './core/NodeList';\nexport * from './core/NodePool';\nexport * from './core/Scene';\nexport * from './core/ComponentsFamily';\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.ts\n **/","/// <reference path=\"../../typings/tsd.d.ts\" />\n\nexport class Dictionary {\n\n    private _keys: any[];\n    private _values: any[];\n\n    constructor() {\n        this._keys = [];\n        this._values = [];\n    }\n\n    public add(key, value) {\n        let keyIndex = this.getIndex(key);\n\n        if (keyIndex >= 0) {\n            this._values[keyIndex] = value;\n        } else {\n            this._keys.push(key);\n            this._values.push(value);\n        }\n    }\n\n    public remove(key):any {\n        let keyIndex = this.getIndex(key);\n\n        if (keyIndex >= 0) {\n            var removedValue = this._values[keyIndex];\n            this._keys.splice(keyIndex, 1);\n            this._values.splice(keyIndex, 1);\n            return removedValue;\n        } else {\n            throw 'Key does not exist';\n        }\n    }\n\n    public getValue(key) {\n        let value = null;\n        let keyIndex = this.getIndex(key);\n\n        if (keyIndex >= 0) {\n            value = this._values[keyIndex];\n        }\n        return value;\n    }\n\n    public getIndex(testKey) {\n        let len = this._keys.length;\n        let key;\n\n        for (let i = 0; i < len; ++i) {\n            key = this._keys[i];\n            if (key === testKey) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public has(testKey) {\n        let len = this._keys.length;\n        let key;\n\n        for (let i = 0; i < len; ++i) {\n            key = this._keys[i];\n            if (key === testKey) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public values(): any[] {\n        let len = this._keys.length;\n        let key;\n        let value;\n        let arValue: any[] = [];\n\n        for (let i = 0; i < len; ++i) {\n            key = this._keys[i];\n            value = this._values[i];\n            arValue.push(value);\n        }\n        return arValue;\n    }\n\n    public forEach(action) {\n        let len = this._keys.length;\n        let key;\n        let value;\n\n        for (let i = 0; i < len; ++i) {\n            key = this._keys[i];\n            value = this._values[i];\n            var breakHere = action(key, value);\n            if (breakHere === 'return') {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/Dictionary.ts\n **/","'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar MiniSignalBinding = (function () {\n  function MiniSignalBinding(fn, once, thisArg) {\n    if (once === undefined) once = false;\n\n    _classCallCheck(this, MiniSignalBinding);\n\n    this._fn = fn;\n    this._once = once;\n    this._thisArg = thisArg;\n    this._next = this._prev = this._owner = null;\n  }\n\n  _createClass(MiniSignalBinding, [{\n    key: 'detach',\n    value: function detach() {\n      if (this._owner === null) return false;\n      this._owner.detach(this);\n      return true;\n    }\n  }]);\n\n  return MiniSignalBinding;\n})();\n\nfunction _addMiniSignalBinding(self, node) {\n  if (!self._head) {\n    self._head = node;\n    self._tail = node;\n  } else {\n    self._tail._next = node;\n    node._prev = self._tail;\n    self._tail = node;\n  }\n\n  node._owner = self;\n\n  return node;\n}\n\nvar MiniSignal = (function () {\n  function MiniSignal() {\n    _classCallCheck(this, MiniSignal);\n\n    this._head = this._tail = undefined;\n  }\n\n  _createClass(MiniSignal, [{\n    key: 'handlers',\n    value: function handlers() {\n      var exists = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\n      var node = this._head;\n\n      if (exists) return !!node;\n\n      var ee = [];\n\n      while (node) {\n        ee.push(node);\n        node = node._next;\n      }\n\n      return ee;\n    }\n  }, {\n    key: 'has',\n    value: function has(node) {\n      if (!(node instanceof MiniSignalBinding)) {\n        throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.');\n      }\n\n      return node._owner === this;\n    }\n  }, {\n    key: 'dispatch',\n    value: function dispatch() {\n      var node = this._head;\n\n      if (!node) return false;\n\n      while (node) {\n        node._fn.apply(node._thisArg, arguments);\n        if (node._once) this.detach(node);\n        node = node._next;\n      }\n\n      return true;\n    }\n  }, {\n    key: 'add',\n    value: function add(fn) {\n      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n      if (typeof fn !== 'function') {\n        throw new Error('MiniSignal#add(): First arg must be a Function.');\n      }\n      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));\n    }\n  }, {\n    key: 'once',\n    value: function once(fn) {\n      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n      if (typeof fn !== 'function') {\n        throw new Error('MiniSignal#once(): First arg must be a Function.');\n      }\n      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));\n    }\n  }, {\n    key: 'detach',\n    value: function detach(node) {\n      if (!(node instanceof MiniSignalBinding)) {\n        throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.');\n      }\n      if (node._owner !== this) return this;\n\n      if (node._prev) node._prev._next = node._next;\n      if (node._next) node._next._prev = node._prev;\n\n      if (node === this._head) {\n        this._head = node._next;\n        if (node._next === null) {\n          this._tail = null;\n        }\n      } else if (node === this._tail) {\n        this._tail = node._prev;\n        this._tail._next = null;\n      }\n\n      node._owner = null;\n      return this;\n    }\n  }, {\n    key: 'detachAll',\n    value: function detachAll() {\n      var node = this._head;\n      if (!node) return this;\n\n      this._head = this._tail = null;\n\n      while (node) {\n        node._owner = null;\n        node = node._next;\n      }\n      return this;\n    }\n  }]);\n\n  return MiniSignal;\n})();\n\nMiniSignal.MiniSignalBinding = MiniSignalBinding;\n\nexports['default'] = MiniSignal;\nmodule.exports = exports['default'];\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mini-signals/lib/mini-signals.js\n ** module id = 2\n ** module chunks = 0\n **/","/**\n *  Linked List implementation in JavaScript, Released under the MIT license\n *  https://github.com/nzakas/computer-science-in-javascript/\n *\n *  @author     Stefan Herndlbauer, 2015, TypeScript conversion\n *  @author     Nicholas C. Zakas, 2009, Doubly Linked List\n *\n *  @url        http://www.gorillabyte.com\n */\n\nexport class LinkedList {\n\n    /**\n     * Pointer to first item in the list.\n     * @property _head\n     * @type Object\n     * @private\n     */\n    private _head = null;\n\n    /**\n     * Pointer to last item in the list.\n     * @property _tail\n     * @type Object\n     * @private\n     */\n    private _tail = null;\n\n    /**\n     * The number of items in the list.\n     * @property _length\n     * @type int\n     * @private\n     */\n    private _length = 0;\n\n    /**\n     * Appends some data to the end of the list. This method traverses\n     * the existing list and places the value at the end in a new item.\n     * @param {any} data The data to add to the list.\n     * @return {Void}\n     * @method add\n     */\n    public add(data) {\n\n        //create a new item object, place data in\n        var node = {\n            data: data,\n            next: null,\n            prev: null\n        };\n\n        //special case: no items in the list yet\n        if (this._length === 0) {\n            this._head = node;\n            this._tail = node;\n        } else {\n\n            //attach to the tail node\n            this._tail.next = node;\n            node.prev = this._tail;\n            this._tail = node;\n        }\n\n        //don't forget to update the count\n        this._length++;\n\n    }\n\n    /**\n     * Retrieves the data in the given position in the list.\n     * @param {int} index The zero-based index of the item whose value\n     *      should be returned.\n     * @return {any} The value in the \"data\" portion of the given item\n     *      or null if the item doesn't exist.\n     * @method item\n     */\n    public item(index) {\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length) {\n            var current = this._head,\n                i = 0;\n\n            while (i++ < index) {\n                current = current.next;\n            }\n\n            return current.data;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Removes the item from the given location in the list.\n     * @param {int} index The zero-based index of the item to remove.\n     * @return {any} The data in the given position in the list or null if\n     *      the item doesn't exist.\n     * @method remove\n     */\n    public remove(index) {\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length) {\n\n            var current = this._head,\n                i = 0;\n\n            //special case: removing first item\n            if (index === 0) {\n                this._head = current.next;\n\n                /*\n                 * If there's only one item in the list and you remove it,\n                 * then this._head will be null. In that case, you should\n                 * also set this._tail to be null to effectively destroy\n                 * the list. Otherwise, set the previous pointer on the new\n                 * this._head to be null.\n                 */\n                if (!this._head) {\n                    this._tail = null;\n                } else {\n                    this._head.prev = null;\n                }\n\n                //special case: removing last item\n            } else if (index === this._length - 1) {\n                current = this._tail;\n                this._tail = current.prev;\n                this._tail.next = null;\n            } else {\n\n                //find the right location\n                while (i++ < index) {\n                    current = current.next;\n                }\n\n                //skip over the item to remove\n                current.prev.next = current.next;\n                current.next.prev = current.prev;\n            }\n\n            //decrement the length\n            this._length--;\n\n            //return the value\n            return current.data;\n\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the number of items in the list.\n     * @return {int} The number of items in the list.\n     * @method size\n     */\n    public size() {\n        return this._length;\n    }\n\n    /**\n     * Converts the list into an array.\n     * @return {Array} An array containing all of the data in the list.\n     * @method toArray\n     */\n    public toArray() {\n        var result = [],\n            current = this._head;\n\n        while (current) {\n            result.push(current.data);\n            current = current.next;\n        }\n        return result;\n    }\n\n    /**\n     * Converts the list into a string representation.\n     * @return {String} A string representation of the list.\n     * @method toString\n     */\n    public toString() {\n        return this.toArray().toString();\n    }\n\n    public get(type) {\n        var current:any = this._head;\n        if(typeof current.data.is === 'function') {\n            while (current) {\n                if (current.data.is(type)) {\n                    return current.data;\n                }\n                current = current.next;\n            }\n        } else {\n            console.log('This type <' + type + '> does not support this method.');\n        }\n        return null;\n    }\n}\n\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/LinkedList.ts\n **/","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n * The default class for managing a NodeList. This class creates the NodeList and adds and removes\n * nodes to/from the list as the entities and the components in the engine change.\n *\n * It uses the basic entity matching pattern of an entity system - entities are added to the list if\n * they contain components matching all the public properties of the node class.\n */\nimport {Node} from './Node';\nimport {NodePool} from './NodePool';\nimport {NodeList} from './NodeList';\nimport {Engine} from './Engine';\nimport {Entity} from './Entity';\nimport {IFamily} from './IFamily';\nimport {Dictionary} from '../utils/Dictionary';\n\nexport class ComponentsFamily implements IFamily {\n    private _nodes:NodeList;\n    private _entities:Dictionary;\n    private _nodeClass;\n    private _components:Dictionary;\n    private _nodePool:NodePool;\n    private _engine:Engine;\n\n    /**\n     * The constructor. Creates a ComponentsFamily to provide a NodeList for the\n     * given node class.\n     *\n     * @param nodeClass The type of node to create and manage a NodeList for.\n     * @param engine The engine that this family is managing teh NodeList for.\n     */\n    constructor(nodeClass:any, engine:Engine) {\n        this._nodeClass = nodeClass;\n        this._engine = engine;\n\n        this._nodes = new NodeList();\n        this._entities = new Dictionary();\n        this._components = new Dictionary();\n\n        var nodeClassPrototype = this._nodeClass.prototype;\n\n        for (var property in nodeClassPrototype) {\n            ///TODO - tidy this up...\n            if (nodeClassPrototype.hasOwnProperty(property) &&\n                property !== 'types' &&\n                property !== 'next' &&\n                property !== 'previous' &&\n                property !== 'constructor' &&\n                property !== 'super' &&\n                property !== 'extend' &&\n                property !== 'entity') {\n                var componentObject = nodeClassPrototype.types[property];\n                this._components.add(componentObject, property);\n            }\n        }\n\n        this._nodePool = new NodePool(this._nodeClass, this._components);\n        this._nodePool.dispose(this._nodePool.get());\n        /*this._nodeClass = nodeClass;\n         this._engine = engine;\n\n         this._nodePool = new silverback.core.NodePool(this._nodeClass);\n         this._nodes = new silverback.core.NodeList();\n         this._entities = new silverback.utils.Dictionary();\n\n         this._components = new silverback.utils.Dictionary();\n         this._nodePool.dispose(this._nodePool.get()); // create a dummy instance to ensure describeType works.\n\n         var nodeClassPrototype = this._nodeClass.prototype;\n\n         for (var property in nodeClassPrototype) {\n         ///TODO - tidy this up...\n         if (nodeClassPrototype.hasOwnProperty(property) &&\n         property !== 'types' &&\n         property !== 'next' &&\n         property !== 'previous' &&\n         property !== 'constructor' &&\n         property !== 'super' &&\n         property !== 'extend' &&\n         property !== 'entity') {\n         var componentObject = nodeClassPrototype.types[property];\n         this._components.add(componentObject, property);\n         }\n         }\n\n         this._init();*/\n    }\n\n    /**\n     * Initialises the class. Creates the nodelist and other tools. Analyses the node to determine\n     * what component types the node requires.\n     */\n    /*private _init()\n     {\n     }*/\n\n    /**\n     * The nodelist managed by this family. This is a reference that remains valid always\n     * since it is retained and reused by Systems that use the list. i.e. we never recreate the list,\n     * we always modify it in place.\n     */\n    public get nodeList():NodeList {\n        return this._nodes;\n    }\n\n    /**\n     * Called by the engine when an entity has been added to it. We check if the entity should be in\n     * this family's NodeList and add it if appropriate.\n     */\n    public newEntity(entity:Entity) {\n        this.addIfMatch(entity);\n    }\n\n    /**\n     * Called by the engine when a component has been added to an entity. We check if the entity is not in\n     * this family's NodeList and should be, and add it if appropriate.\n     */\n    public componentAddedToEntity(entity:Entity, componentClass:() => any) {\n        this.addIfMatch(entity);\n    }\n\n    /**\n     * Called by the engine when a component has been removed from an entity. We check if the removed component\n     * is required by this family's NodeList and if so, we check if the entity is in this this NodeList and\n     * remove it if so.\n     */\n    public componentRemovedFromEntity(entity:Entity, componentClass:() => any) {\n        if (this._components.has(componentClass)) {\n            this.removeIfMatch(entity);\n        }\n    }\n\n    /**\n     * Called by the engine when an entity has been rmoved from it. We check if the entity is in\n     * this family's NodeList and remove it if so.\n     */\n    public removeEntity(entity:Entity) {\n        this.removeIfMatch(entity);\n    }\n\n    /**\n     * If the entity is not in this family's NodeList, tests the components of the entity to see\n     * if it should be in this NodeList and adds it if so.\n     */\n    public addIfMatch(entity:Entity) {\n        if (!this._entities.has(entity)) {\n            this._components.forEach((componentClass) => {\n                if (!entity.has(componentClass)) {\n                    return;\n                }\n            });\n\n            var node = this._nodePool.get();\n            node.entity = entity;\n            this._components.forEach(function (componentClass, componentName) {\n                node[componentName] = entity.get(componentClass);\n            });\n            this._entities.add(entity, node);\n            this._nodes.add(node);\n        }\n    }\n\n    /**\n     * Removes the entity if it is in this family's NodeList.\n     */\n    public removeIfMatch(entity:Entity) {\n        if (this._entities.getValue(entity)) {\n            var node:Node = this._entities.getValue(entity);\n            this._entities.remove(entity);\n            this._nodes.remove(node);\n            if (this._engine.updating) {\n                this._nodePool.cache(node);\n                this._engine.updateComplete.add(this._releaseNodePoolCache, this);\n            } else {\n                this._nodePool.dispose(node);\n            }\n        }\n    }\n\n    /**\n     * Releases the nodes that were added to the node pool during this engine update, so they can\n     * be reused.\n     */\n    private _releaseNodePoolCache() {\n        this._engine.updateComplete.detachAll();\n        this._nodePool.releaseCache();\n    }\n\n    /**\n     * Removes all nodes from the NodeList.\n     */\n    public cleanUp() {\n        for (var node:Node = this._nodes.head; node; node = node.next) {\n            this._entities.remove(node.entity);\n        }\n        this._nodes.removeAll();\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/ComponentsFamily.ts\n **/","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n\n/**\n * A collection of nodes.\n *\n * <p>Systems within the engine access the components of entities via NodeLists. A NodeList contains\n * a node for each Entity in the engine that has all the components required by the node. To iterate\n * over a NodeList, start from the head and step to the next on each loop, until the returned value\n * is null.</p>\n *\n * <p>for( var node : Node = nodeList.head; node; node = node.next )\n * {\n\t *   // do stuff\n\t * }</p>\n *\n * <p>It is safe to remove items from a nodelist during the loop. When a Node is removed form the\n * NodeList it's previous and next properties still point to the nodes that were before and after\n * it in the NodeList just before it was removed.</p>\n */\n\nimport {Node} from './Node';\nconst MiniSignal = require('../../node_modules/mini-signals');\n\nexport class NodeList {\n    /**\n     * The first item in the node list, or null if the list contains no nodes.\n     */\n    public head:any = null;\n    /**\n     * The last item in the node list, or null if the list contains no nodes.\n     */\n    public tail:any = null;\n\n    /**\n     * A signal that is dispatched whenever a node is added to the node list.\n     *\n     * <p>The signal will pass a single parameter to the listeners - the node that was added.</p>\n     */\n    public nodeAdded;\n    /**\n     * A signal that is dispatched whenever a node is removed from the node list.\n     *\n     * <p>The signal will pass a single parameter to the listeners - the node that was removed.</p>\n     */\n    public nodeRemoved;\n\n    constructor() {\n        this.nodeAdded = new MiniSignal();\n        this.nodeRemoved = new MiniSignal();\n    }\n\n    public add(node:Node):void {\n        if (!this.head) {\n            this.head = this.tail = node;\n            node.next = node.previous = null;\n        } else {\n            this.tail.next = node;\n            node.previous = this.tail;\n            node.next = null;\n            this.tail = node;\n        }\n        this.nodeAdded.dispatch(node);\n    }\n\n    public remove(node:Node) {\n        if (this.head === node) {\n            this.head = this.head.next;\n        }\n        if (this.tail === node) {\n            this.tail = this.tail.previous;\n        }\n        if (node.previous) {\n            node.previous.next = node.next;\n        }\n        if (node.next) {\n            node.next.previous = node.previous;\n        }\n        this.nodeRemoved.dispatch(node);\n        // N.B. Don't set node.next and node.previous to null because that will break the list iteration if node is\n        // the current node in the iteration.\n    }\n\n    public removeAll() {\n        while (this.head) {\n            var node:Node = this.head;\n            this.head = node.next;\n            node.previous = null;\n            node.next = null;\n            this.nodeRemoved.dispatch(node);\n        }\n        this.tail = null;\n    }\n\n    /**\n     * true if the list is empty, false otherwise.\n     */\n    public empty():boolean {\n        return this.head === null;\n    }\n\n    /**\n     * Swaps the positions of two nodes in the list. Useful when sorting a list.\n     */\n    public swap(node1:Node, node2:Node) {\n        if (node1.previous === node2) {\n            node1.previous = node2.previous;\n            node2.previous = node1;\n            node2.next = node1.next;\n            node1.next = node2;\n        } else if (node2.previous === node1) {\n            node2.previous = node1.previous;\n            node1.previous = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n        } else {\n            var temp:Node = node1.previous;\n            node1.previous = node2.previous;\n            node2.previous = temp;\n            temp = node1.next;\n            node1.next = node2.next;\n            node2.next = temp;\n        }\n\n        if (this.head === node1) {\n            this.head = node2;\n        } else if (this.head === node2) {\n            this.head = node1;\n        }\n        if (this.tail === node1) {\n            this.tail = node2;\n        } else if (this.tail === node2) {\n            this.tail = node1;\n        }\n\n        if (node1.previous) {\n            node1.previous.next = node1;\n        }\n        if (node2.previous) {\n            node2.previous.next = node2;\n        }\n        if (node1.next) {\n            node1.next.previous = node1;\n        }\n        if (node2.next) {\n            node2.next.previous = node2;\n        }\n    }\n\n    /**\n     * Performs an insertion sort on the node list. In general, insertion sort is very efficient with short lists\n     * and with lists that are mostly sorted, but is inefficient with large lists that are randomly ordered.\n     *\n     * <p>The sort function takes two nodes and returns a Number.</p>\n     *\n     * <p><code>function sortFunction( node1 : MockNode, node2 : MockNode ) :number</code></p>\n     *\n     * <p>If the returned number is less than zero, the first node should be before the second. If it is greater\n     * than zero the second node should be before the first. If it is zero the order of the nodes doesn't matter\n     * and the original order will be retained.</p>\n     *\n     * <p>This insertion sort implementation runs in place so no objects are created during the sort.</p>\n     */\n    public insertionSort(sortFunction) {\n        if (this.head === this.tail) {\n            return;\n        }\n        var remains:Node = this.head.next;\n        for (var node:Node = remains; node; node = remains) {\n            remains = node.next;\n            for (var other:Node = node.previous; other; other = other.previous) {\n                if (sortFunction(node, other) >= 0) {\n                    // move node to after other\n                    if (node !== other.next) {\n                        // remove from place\n                        if (this.tail === node) {\n                            this.tail = node.previous;\n                        }\n                        node.previous.next = node.next;\n                        if (node.next) {\n                            node.next.previous = node.previous;\n                        }\n                        // insert after other\n                        node.next = other.next;\n                        node.previous = other;\n                        node.next.previous = node;\n                        other.next = node;\n                    }\n                    break; // exit the inner for loop\n                }\n            }\n            if (!other) { // the node belongs at the start of the list\n                // remove from place\n                if (this.tail === node) {\n                    this.tail = node.previous;\n                }\n                node.previous.next = node.next;\n                if (node.next) {\n                    node.next.previous = node.previous;\n                }\n                // insert at head\n                node.next = this.head;\n                this.head.previous = node;\n                node.previous = null;\n                this.head = node;\n            }\n        }\n    }\n\n    /**\n     * Performs a merge sort on the node list. In general, merge sort is more efficient than insertion sort\n     * with long lists that are very unsorted.\n     *\n     * <p>The sort function takes two nodes and returns a Number.</p>\n     *\n     * <p><code>function sortFunction( node1 : MockNode, node2 : MockNode ) :number</code></p>\n     *\n     * <p>If the returned number is less than zero, the first node should be before the second. If it is greater\n     * than zero the second node should be before the first. If it is zero the order of the nodes doesn't matter.</p>\n     *\n     * <p>This merge sort implementation creates and uses a single Vector during the sort operation.</p>\n     */\n    public mergeSort(sortFunction) {\n        if (this.head === this.tail) {\n            return;\n        }\n        //var lists: Vector.<Node> = new Vector.< Node >;\n        var lists:any;\n        // disassemble the list\n        var start:Node = this.head;\n        var end:Node;\n        while (start) {\n            end = start;\n            while (end.next && sortFunction(end, end.next) <= 0) {\n                end = end.next;\n            }\n            var next:Node = end.next;\n            start.previous = end.next = null;\n            lists.push(start);\n            start = next;\n        }\n        // reassemble it in order\n        while (lists.length > 1) {\n            //TODO VECTOR CLASS\n            //lists.push( merge( lists.shift(), lists.shift(), sortFunction ) );\n        }\n        // find the tail\n        this.tail = this.head = lists[0];\n        while (this.tail.next) {\n            this.tail = this.tail.next;\n        }\n    }\n\n    private _merge(head1:Node, head2:Node, sortFunction):Node {\n        var node:Node;\n        var head:Node;\n        if (sortFunction(head1, head2) <= 0) {\n            head = node = head1;\n            head1 = head1.next;\n        } else {\n            head = node = head2;\n            head2 = head2.next;\n        }\n        while (head1 && head2) {\n            if (sortFunction(head1, head2) <= 0) {\n                node.next = head1;\n                head1.previous = node;\n                node = head1;\n                head1 = head1.next;\n            } else {\n                node.next = head2;\n                head2.previous = node;\n                node = head2;\n                head2 = head2.next;\n            }\n        }\n        if (head1) {\n            node.next = head1;\n            head1.previous = node;\n        } else {\n            node.next = head2;\n            head2.previous = node;\n        }\n        return head;\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/NodeList.ts\n **/","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n * This export class maintains a pool of deleted nodes for reuse by the framework. This reduces the overhead\n * from object creation and garbage collection.\n *\n * Because nodes may be deleted from a NodeList while in use, by deleting Nodes from a NodeList\n * while iterating through the NodeList, the pool also maintains a cache of nodes that are added to the pool\n * but should not be reused yet. They are then released into the pool by calling the releaseCache method.\n */\nimport {Node} from './Node';\n\nexport class NodePool {\n    private _tail:Node;\n    private _nodeClass;\n    private _cacheTail:Node;\n    private _components;\n\n    /**\n     * Creates a pool for the given node class.\n     */\n    constructor(nodeClass, components) {\n        this._nodeClass = nodeClass;\n        this._components = components;\n    }\n\n    /**\n     * Fetches a node from the pool.\n     */\n    public get() {\n        if (this._tail) {\n            var node = this._tail;\n            this._tail = this._tail.previous;\n            node.previous = null;\n            return node;\n        } else {\n            var newNode = new this._nodeClass;\n            return newNode;\n        }\n    }\n\n    /**\n     * Adds a node to the pool.\n     */\n    public dispose(node:Node) {\n        this._components.forEach(function (componentClass, componentName) {\n            node[componentName] = null;\n        });\n        node.entity = null;\n        node.next = null;\n        node.previous = this._tail;\n        this._tail = node;\n    }\n\n    /**\n     * Adds a node to the cache\n     */\n    public cache(node:Node) {\n        node.previous = this._cacheTail;\n        this._cacheTail = node;\n    }\n\n    /**\n     * Releases all nodes from the cache into the pool\n     */\n    public releaseCache() {\n        while (this._cacheTail) {\n            var node:Node = this._cacheTail;\n            this._cacheTail = node.previous;\n            node.next = null;\n            node.previous = this._tail;\n            this._tail = node;\n        }\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/NodePool.ts\n **/","/**\n * @module Silverback\n * @class Engine\n */\n\n/// <reference path=\"../../typings/tsd.d.ts\" />\n\nimport {Entity} from './Entity';\nimport {Scene} from './Scene';\nimport {NodeList} from './NodeList';\nimport {Dictionary} from '../utils/Dictionary';\nimport {LinkedList} from '../utils/LinkedList';\nimport {System} from './System';\nimport {ComponentsFamily} from './ComponentsFamily';\nimport {IFamily} from './IFamily';\n\nconst MiniSignal = require('../../node_modules/mini-signals');\n\n/**\n * The Engine class is the central point for creating and managing your game state. Add\n * entities and systems to the engine, and fetch families of nodes from the engine.\n */\nexport class Engine {\n\n    private _systemList:LinkedList;\n    private _entityList:LinkedList;\n    private _sceneList:LinkedList;\n    private _entityNames:Dictionary;\n    private _sceneNames:Dictionary;\n    private _families:Dictionary;\n\n    /**\n     * Indicates if the engine is currently in its update loop.\n     */\n    public updating:boolean;\n\n    /**\n     * Dispatched when the update loop ends. If you want to add and remove systems from the\n     * engine it is usually best not to do so during the update loop. To avoid this you can\n     * listen for this signal and make the change when the signal is dispatched.\n     */\n    public updateComplete:MiniSignal;\n\n    /**\n     * The class used to manage node lists. In most cases the default class is sufficient\n     * but it is exposed here so advanced developers can choose to create and use a\n     * different implementation.\n     *\n     * The class must implement the Family interface.\n     */\n    public familyClass;\n\n    constructor() {\n        this._systemList = new LinkedList();\n        this._entityList = new LinkedList();\n        this._sceneList = new LinkedList();\n        this._entityNames = new Dictionary();\n        this._sceneNames = new Dictionary();\n        this._families = new Dictionary();\n        this.updateComplete = new MiniSignal();\n\n        this.familyClass = ComponentsFamily;\n    }\n\n    /**\n     * Returns an array containing all the entities in the engine.\n     */\n    public get entities():Array<Entity> {\n        return this._entityList.toArray();\n    }\n\n    /**\n     * Returns an array containing all the scenes in the engine.\n     */\n    public get scenes():Array<Scene> {\n        return this._sceneList.toArray();\n    }\n\n    /**\n     * Returns an array containing all the systems in the engine.\n     */\n    public get systems():Array<System> {\n        return this._systemList.toArray();\n    }\n\n    /**\n     * Add an entity to the engine.\n     *\n     * @param entity The entity to add.\n     */\n    public addEntity(entity:Entity):void {\n        if(this._entityNames.has(entity.name)) {\n            throw new Error('The entity name ' + entity.name + ' is already in use by another entity.');\n        }\n        this._entityList.add(entity);\n        this._entityNames.add(entity.name, entity);\n        entity.componentAdded.add(this._componentAdded, this);\n        entity.componentRemoved.add(this._componentRemoved, this);\n        entity.nameChanged.add(this._entityNameChanged, this);\n\n        this._families.forEach((nodeObject, family:IFamily) => {\n                family.newEntity(entity);\n            }\n        );\n    }\n\n    /**\n     * Remove an entity from the engine.\n     *\n     * @param entity The entity to remove.\n     * @param index The index of the entity list.\n     */\n    public removeEntity(entity: Entity, index?:number):void {\n        /*entity.componentAdded.remove(this._componentAdded, this);\n        entity.componentRemoved.remove(this._componentRemoved, this);\n        entity.nameChanged.remove(this._entityNameChanged, this);*/\n        entity.componentAdded.detachAll();\n        entity.componentRemoved.detachAll();\n        entity.nameChanged.detachAll();\n\n        this._families.forEach((nodeObject, family: IFamily) => {\n                family.removeEntity(entity);\n            }\n        );\n        this._entityNames.remove(entity.name);\n        this._entityList.remove(index);\n    }\n\n    /**\n     * Get an entity based on its name.\n     *\n     * @param name The name of the entity\n     * @return The entity, or null if no entity with that name exists on the engine\n     */\n    public getEntityByName(name:string):Entity {\n        if(this._entityNames.has(name)) {\n            return this._entityNames.getValue(name);\n        }\n        return null;\n    }\n\n    /**\n     * Remove all entities from the engine.\n     */\n    public removeAllEntities():void {\n        let listSize = this._entityList.size() - 1;\n        for (let i = listSize; i >= 0; i--) {\n            this.removeEntity(this._entityList.item(i), i);\n        }\n    }\n\n    /**\n     * Add an scene to the engine.\n     *\n     * @param scene The scene to add.\n     */\n    public addScene(scene:Scene):void {\n        this._sceneList.add(scene);\n        this._sceneNames.add(scene.name, scene);\n        scene.nameChanged.add(this._sceneNameChanged, this);\n\n    }\n\n    /**\n     * Remove an scene from the engine.\n     *\n     * @param scene The scene to remove.\n     * @param index The scene index in the sceneList\n     */\n    public removeScene(scene:Scene, index?:number):void {\n        if(typeof index === 'undefined') {\n            for (let i = 0; i < this._sceneList.size(); i++) {\n                if(this._sceneList.item(i) === scene) {\n                    this._sceneList.remove(i);\n                }\n            }\n        } else {\n            this._sceneList.remove(index);\n        }\n        this._sceneNames.remove(scene.name);\n        scene.nameChanged.detachAll();\n    }\n\n    /**\n     * Remove all scenes from the engine.\n     */\n    public removeAllScenes():void {\n        let listSize = this._sceneList.size() - 1;\n        for (let i = listSize; i >= 0; i--) {\n            this.removeScene(this._sceneList.item(i), i);\n        }\n    }\n\n    /**\n     * Get an scene based on its name.\n     *\n     * @param name The name of the scene\n     * @return The scene, or null if no scene with that name exists on the engine\n     */\n    public getSceneByName(name:string):Scene {\n        if(this._sceneNames.has(name)) {\n            return this._sceneNames.getValue(name);\n        }\n        return null;\n    }\n\n    /**\n     * Get the scene instance of a particular type from within the engine.\n     *\n     * @param type The type of scene\n     * @return The instance of the scene type that is in the engine, or\n     * null if no scene of this type are in the engine.\n     */\n    public getScene(type):Scene {\n        return this._sceneList.get(type);\n    }\n\n    /**\n     * Get a collection of nodes from the engine, based on the type of the node required.\n     *\n     * <p>The engine will create the appropriate NodeList if it doesn't already exist and\n     * will keep its contents up to date as entities are added to and removed from the\n     * engine.</p>\n     *\n     * <p>If a NodeList is no longer required, release it with the releaseNodeList method.</p>\n     *\n     * @param nodeClass The type of node required.\n     * @return A linked list of all nodes of this type from all entities in the engine.\n     */\n    public getNodeList(nodeClass):NodeList {\n        if(this._families.has(nodeClass)) {\n            return this._families.getValue(nodeClass)._nodes;\n        }\n        var family = new this.familyClass(nodeClass, this);\n        this._families.add(nodeClass, family);\n        for (let i = 0; i < this._entityList.size(); i++) {\n            family.newEntity(this._entityList.item(i));\n        }\n        return family.nodeList;\n    }\n\n    /**\n     * If a NodeList is no longer required, this method will stop the engine updating\n     * the list and will release all references to the list within the framework\n     * classes, enabling it to be garbage collected.\n     *\n     * <p>It is not essential to release a list, but releasing it will free\n     * up memory and processor resources.</p>\n     *\n     * @param nodeClass The type of the node class if the list to be released.\n     */\n    public releaseNodeList(nodeClass) {\n        if(this._families.has(nodeClass)) {\n            this._families.getValue(nodeClass).cleanUp();\n        } else {\n            throw new Error('The given nodeClass was not found and can not be released.');\n        }\n        this._families.remove(nodeClass);\n    }\n\n    /**\n     * Add a system to the engine, and set its priority for the order in which the\n     * systems are updated by the engine update loop.\n     *\n     * <p>The priority dictates the order in which the systems are updated by the engine update\n     * loop. Lower numbers for priority are updated first. i.e. a priority of 1 is\n     * updated before a priority of 2.</p>\n     *\n     * @param system The system to add to the engine.\n     * @param priority The priority for updating the systems during the engine loop. A\n     * lower number means the system is updated sooner.\n     */\n    public addSystem(system:System, priority:number) {\n        system.priority = priority;\n        system.addToEngine(this);\n        this._systemList.add(system);\n    }\n\n    /**\n     * Get the system instance of a particular type from within the engine.\n     *\n     * @param type The type of system\n     * @return The instance of the system type that is in the engine, or\n     * null if no systems of this type are in the engine.\n     */\n    public getSystem(type):System {\n        return this._systemList.get(type);\n    }\n\n    /**\n     * Remove a system from the engine.\n     *\n     * @param system The system to remove from the engine.\n     * @param index The system index in the system list.\n     */\n    public removeSystem(system:System, index?:number) {\n        if(typeof index === 'undefined') {\n            for (let i = 0; i < this._systemList.size(); i++) {\n                if(this._systemList.item(i) === system) {\n                    this._systemList.remove(i);\n                }\n            }\n        } else {\n            this._systemList.remove(index);\n        }\n        system.removeFromEngine(this);\n    }\n\n    /**\n     * Remove all systems from the engine.\n     */\n    public removeAllSystems():void {\n        let listSize = this._systemList.size() - 1;\n        for (let i = listSize; i >= 0; i--) {\n            this.removeSystem(this._systemList.item(i), i);\n        }\n    }\n\n    /**\n     * Update the engine. This causes the engine update loop to run, calling update on all the\n     * systems in the engine.\n     *\n     * @time The duration, in seconds, of this update step.\n     */\n    public update(time:number):void {\n        this.updating = true;\n        let systemSize = this._systemList.size();\n        for (let i = 0; i < systemSize; i++) {\n            this._systemList.item(i).update(time);\n        }\n        this.updating = false;\n        this.updateComplete.dispatch();\n    }\n\n    /**\n     * @private\n     */\n    private _entityNameChanged(entity:Entity, oldName:string):void {\n        if(this._entityNames.has(oldName)) {\n            this._entityNames.remove(oldName);\n            this._entityNames.add(entity.name, entity);\n        } else {\n            throw new Error('The given name was not found in the entity list.');\n        }\n    }\n\n    /**\n     * @private\n     */\n    private _sceneNameChanged(scene:Scene, oldName:string):void {\n        if(this._sceneNames.has(oldName)) {\n            this._sceneNames.remove(oldName);\n            this._sceneNames.add(scene.name, scene);\n        } else {\n            throw new Error('The given name was not found in the scene list.');\n        }\n    }\n\n    /**\n     * @private\n     */\n    private _componentAdded(entity:Entity, componentClass:() => any):void {\n        this._families.forEach((nodeObject, family:IFamily) => {\n                family.componentAddedToEntity(entity, componentClass);\n            }\n        );\n    }\n\n    /**\n     * @private\n     */\n    private _componentRemoved(entity:Entity, componentClass:() => any):void {\n        this._families.forEach((nodeObject, family:IFamily) => {\n                family.componentRemovedFromEntity(entity, componentClass);\n            }\n        );\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Engine.ts\n **/","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n * An entity is composed from components. As such, it is essentially a collection object for components.\n * Sometimes, the entities in a game will mirror the actual characters and objects in the game, but this\n * is not necessary.\n *\n * <p>Components are simple value objects that contain data relevant to the entity. Entities\n * with similar functionality will have instances of the same components. So we might have\n * a position component</p>\n *\n * <p><code>export class PositionComponent\n * {\n *   public x :number;\n *   public y :number;\n * }</code></p>\n *\n * <p>All entities that have a position in the game world, will have an instance of the\n * position component. Systems operate on entities based on the components they have.</p>\n */\n\nimport {Scene} from './Scene';\n//import {Signal} from '../utils/Signal';\nimport {Dictionary} from '../utils/Dictionary';\nconst MiniSignal = require('../../node_modules/mini-signals');\n\nexport class Entity {\n\n    private static nameCount = 0;\n    /**\n     * Optional, give the entity a name. This can help with debugging and with serialising the entity.\n     */\n    private _name:string;\n\n    /**\n     * This signal is dispatched when a component is added to the entity.\n     */\n    public componentAdded;\n\n    /**\n     * This signal is dispatched when a component is removed from the entity.\n     */\n    public componentRemoved;\n\n    /**\n     * Dispatched when the name of the entity changes.\n     * Used internally by the engine to track entities based on their names.\n     */\n    public nameChanged;\n\n    public previous:Entity;\n    public next:Entity;\n    private _components:Dictionary;\n    private _addedToScene:Scene;\n\n    constructor(name:string = '') {\n        this._components = new Dictionary();\n        this.componentAdded = new MiniSignal();\n        this.componentRemoved = new MiniSignal();\n        this.nameChanged = new MiniSignal();\n\n        if(name.length > 0) {\n            this._name = name;\n        } else {\n            this._name = '_entity' + (++Entity.nameCount);\n        }\n    }\n\n    /**\n     * All entities have a name. If no name is set, a default name is used. Names are used to\n     * fetch specific entities from the engine, and can also help to identify an entity when debugging.\n     */\n    public get name():string {\n        return this._name;\n    }\n    public set name(value:string) {\n        if(this._name !== value) {\n            var previous:string = this._name;\n            this._name = value;\n            this.nameChanged.dispatch(this, previous);\n        }\n    }\n\n    /**\n     * Add a component to the entity.\n     *\n     * @param component The component object to add.\n     * @param componentClass The class of the component. This is only necessary if the component\n     * extends another component class and you want the framework to treat the component as of\n     * the base class type. If not set, the class type is determined directly from the component.\n     *\n     * @return A reference to the entity. This enables the chaining of calls to add, to make\n     * creating and configuring entities cleaner. e.g.\n     *\n     * <code>var entity : Entity = new Entity()\n     *     .add(new Position(100, 200))\n     *     .add(new Display(new PlayerClip());</code>\n     */\n    public add(component: any, componentClass?):Entity {\n        if( typeof componentClass === 'undefined' ) {\n            componentClass = component.constructor;\n        }\n        if ( this._components.has( componentClass ) ) {\n            this.remove( componentClass );\n        }\n        this._components.add(componentClass, component);\n        this.componentAdded.dispatch( this, componentClass );\n        return this;\n    }\n\n    /**\n     * Remove a component from the entity.\n     *\n     * @param componentClass The class of the component to be removed.\n     * @return the component, or null if the component doesn't exist in the entity\n     */\n    public remove(componentClass):any {\n        var component:any = this._components.getValue(componentClass);\n        if (component) {\n            this._components.remove( componentClass );\n            this.componentRemoved.dispatch(this, componentClass);\n            return component;\n        }\n        return null;\n    }\n\n    /**\n     * Get a component from the entity.\n     *\n     * @param componentClass The class of the component requested.\n     * @return The component, or null if none was found.\n     */\n    public get (componentClass:any):any {\n        return this._components.getValue(componentClass);\n    }\n\n    /**\n     * Get all components from the entity.\n     *\n     * @return An array containing all the components that are on the entity.\n     */\n    public getAll():any[] {\n        var componentArray = [];\n\n        this._components.forEach(\n            (componentClass, component) => {\n                componentArray.push(component);\n            }\n        );\n        return componentArray;\n    }\n\n    /**\n     * Does the entity have a component of a particular type.\n     *\n     * @param componentClass The class of the component sought.\n     * @return true if the entity has a component of the type, false if not.\n     */\n    public has(componentClass:any):boolean {\n        return this._components.has(componentClass);\n    }\n\n    public set scene(scene:Scene) {\n        this._addedToScene = scene;\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Entity.ts\n **/","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n * The base class for a node.\n *\n * <p>A node is a set of different components that are required by a system.\n * A system can request a collection of nodes from the engine. Subsequently the Engine object creates\n * a node for every entity that has all of the components in the node class and adds these nodes\n * to the list obtained by the system. The engine keeps the list up to date as entities are added\n * to and removed from the engine and as the components on entities change.</p>\n */\nimport {Entity} from './Entity';\n\nexport class Node {\n    /**\n     * The entity whose components are included in the node.\n     */\n    public entity:Entity = null;\n\n    /**\n     * Used by the NodeList class. The previous node in a node list.\n     */\n    public previous:any = null;\n\n    /**\n     * Used by the NodeList class. The next node in a node list.\n     */\n    public next:any = null;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Node.ts\n **/","/// <reference path=\"../../typings/tsd.d.ts\" />\n\nimport {LinkedList} from '../utils/LinkedList';\nimport {Dictionary} from '../utils/Dictionary';\nconst MiniSignal = require('../../node_modules/mini-signals');\n\nexport class Scene {\n\n    private static nameCount = 0;\n    /**\n     * Optional, give the scene a name. This can help with debugging and with serialising the scenes.\n     */\n    private _name:string;\n\n    /**\n     * This signal is dispatched when a entity is added to the scene.\n     */\n    public entityAdded;\n\n    /**\n     * This signal is dispatched when a entity is removed from the scene.\n     */\n    public entityRemoved;\n\n    /**\n     * Dispatched when the name of the scene changes.\n     * Used internally by the engine to track entities based on their names.\n     */\n    public nameChanged;\n\n    public previous:Scene;\n    public next:Scene;\n\n    private _entities:Dictionary;\n    private _entityList:LinkedList;\n\n    constructor(name:string = '') {\n        this._entities = new Dictionary();\n        this.entityAdded = new MiniSignal();\n        this.entityRemoved = new MiniSignal();\n        this._entityList = new LinkedList();\n        this.nameChanged = new MiniSignal();\n\n        if (name) {\n            this._name = name;\n        } else {\n            this._name = '_scene' + (++Scene.nameCount);\n        }\n    }\n\n    /**\n     * All scenes have a name. If no name is set, a default name is used. Names are used to\n     * fetch specific scenes from the engine, and can also help to identify an entity when debugging.\n     */\n    public get name():string {\n        return this._name;\n    }\n    public set name(value:string) {\n        if(this._name !== value) {\n            var previous:string = this._name;\n            this._name = value;\n            this.nameChanged.dispatch(this, previous);\n        }\n    }\n\n    /**\n     * Add a entity to the scene.\n     *\n     * @param entity The entity object to add.\n     * @param entityClass The class of the entity. This is only necessary if the entity\n     * extends another entity class and you want the framework to treat the entity as of\n     * the base class type. If not set, the class type is determined directly from the entity.\n     *\n     * @return A reference to the scene. This enables the chaining of calls to add, to make\n     * creating and configuring entities cleaner. e.g.\n     *\n     */\n    public addEntity(entity:any, entityClass?):Scene {\n        if (typeof entityClass === 'undefined') {\n            entityClass = entity.constructor;\n        }\n        /*\n         if ( this._entities.has( entityClass ) ) {\n         this.removeEntity( entityClass );\n         }*/\n        this._entityList.add(entity);\n        this.entityAdded.dispatch(this, entityClass);\n        entity.scene = this;\n        return this;\n    }\n\n    /**\n     * Remove a entity from the scene.\n     *\n     * @param entityClass The class of the entity to be removed.\n     * @return the entity, or null if the entity doesn't exist in the entity\n     */\n    public removeEntity(entity):any {\n        this._entityList.remove(entity);\n\n        /*var entity:any = this._entities.getValue(entityClass);\n         if (entity) {\n         this._entities.remove( entityClass );\n         this.entityRemoved.dispatch(this, entityClass);\n         return entity;\n         }\n         return null;*/\n    }\n\n    /**\n     * Get a entity from the scene.\n     *\n     * @param entityName The class of the entity requested.\n     * @return The entity, or null if none was found.\n     */\n    public getEntityWithName(entityName:any):any {\n        //return this._entities.getValue(entityClass);\n        for (let i = 0; i < this._entityList.size(); i++) {\n            if (this._entityList.item(i).name === entityName) {\n                return this._entityList.item(i);\n            }\n        }\n    }\n\n    /**\n     * Get a entity with component from the scene.\n     *\n     * @param entityClass The class of the entity requested.\n     * @return The entity, or null if none was found.\n     */\n    public getEntityWithComponent(_component:any, _componentClass:any):any {\n\n        for (let i = 0; i < this._entityList.size(); i++) {\n            if (this._entityList.item(i).has(_componentClass)) {\n                if (this._entityList.item(i).get(_componentClass).displayObject === _component) {\n                    return this._entityList.item(i);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get all entities from the scene.\n     *\n     * @return An array containing all the entities that are on the scene.\n     */\n    public getAllEntity():any[] {\n        var entityArray = [];\n\n        this._entities.forEach(\n            (entityClass, entity) => {\n                entityArray.push(entity);\n            }\n        );\n        return entityArray;\n    }\n\n    /**\n     * Does the entity have a entity of a particular type.\n     *\n     * @param entityClass The class of the entity sought.\n     * @return true if the entity has a entity of the type, false if not.\n     */\n    public hasEntity(entityClass:any):boolean {\n        return this._entities.has(entityClass);\n    }\n\n    public is(type) {\n        return type.prototype.isPrototypeOf(this);\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Scene.ts\n **/","/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n * The abstract class for a system implementation.\n *\n * <p>A system is part of the core functionality of the game. After a system is added to the engine, its\n * update method will be called on every frame of the engine. When the system is removed from the engine,\n * the update method is no longer called.</p>\n *\n * <p>The aggregate of all systems in the engine is the functionality of the game, with the update\n * methods of those systems collectively constituting the engine update loop. Systems generally operate on\n * node lists - collections of nodes. Each node contains the components from an entity in the engine\n * that match the node.</p>\n */\nexport abstract class System {\n\n    /**\n     * Used internally to manage the list of systems within the engine. The previous system in the list.\n     */\n    public previous:System = null;\n\n    /**\n     * Used internally to manage the list of systems within the engine. The next system in the list.\n     */\n    public next:System = null;\n\n    /**\n     * Used internally to hold the priority of this system within the system list. This is\n     * used to order the systems so they are updated in the correct order.\n     */\n    public priority:number = 0;\n\n    /**\n     * Called just after the system is added to the engine, before any calls to the update method.\n     * Override this method to add your own functionality.\n     *\n     * @param engine The engine the system was added to.\n     */\n    public addToEngine(engine:any):void {\n        throw new Error('Don\\'t call the abstract class directly, this method must be overridden.');\n    }\n\n    /**\n     * Called just after the system is removed from the engine, after all calls to the update method.\n     * Override this method to add your own functionality.\n     *\n     * @param engine The engine the system was removed from.\n     */\n    public removeFromEngine(engine:any):void {\n        throw new Error('Don\\'t call the abstract class directly, this method must be overridden.');\n    }\n\n    /**\n     * After the system is added to the engine, this method is called every frame until the system\n     * is removed from the engine. Override this method to add your own functionality.\n     *\n     * <p>If you need to perform an action outside of the update loop (e.g. you need to change the\n     * systems in the engine and you don't want to do it while they're updating) add a listener to\n     * the engine's updateComplete signal to be notified when the update loop completes.</p>\n     *\n     * @param time The duration, in seconds, of the frame.\n     */\n    public update(time:number) {\n        throw new Error('Don\\'t call the abstract class directly, this method must be overridden.');\n    }\n\n    public is(type) {\n        return type.prototype.isPrototypeOf(this);\n    }\n}\n\nSystem.prototype.previous = null;\nSystem.prototype.next = null;\nSystem.prototype.priority = 0;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/System.ts\n **/"],"sourceRoot":""}